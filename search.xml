<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>基本架构：一个键值数据库包含什么？</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="Redis主体"><a href="#Redis主体" class="headerlink" title="Redis主体"></a><code>Redis</code>主体</h1><p><strong><code>Redis</code>知识整体框架</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/79da7093ed998a99d9abe91e610b74e7.jpg" alt="img" style="zoom: 25%;" />

<ul>
<li><strong>高性能主线：</strong> 包括线程模型、数据结构、持久化、网络框架；</li>
<li><strong>高可靠主线：</strong>包括主从复制、哨兵机制；</li>
<li><strong>高可扩展主线：</strong>包括数据分片、负载均衡。</li>
</ul>
<span id="more"></span>

<p><strong><code>Redis</code>问题排查方法</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/70a5bc1ddc9e3579a2fcb8a5d44118b4.jpeg" alt="img" style="zoom: 25%;" />



<h1 id="01-基本架构：一个键值数据库包含什么？"><a href="#01-基本架构：一个键值数据库包含什么？" class="headerlink" title="01 | 基本架构：一个键值数据库包含什么？"></a>01 | 基本架构：一个键值数据库包含什么？</h1><h2 id="可以存哪些数据？"><a href="#可以存哪些数据？" class="headerlink" title="可以存哪些数据？"></a>可以存哪些数据？</h2><ul>
<li>对于键值数据库而言，基本的数据模型是 key-value 模型。</li>
<li>不同键值数据库支持的 key 类型一般差异不大，而 value 类型则有较大差别。我们在对键值数据库进行选型时，一个重要的考虑因素是它支持的 value 类型。例如，<code>Memcached</code> 支持的 value 类型仅为 String 类型，而 <code>Redis</code> 支持的 value 类型包括了 String、哈希表、列表、集合等。 <strong><code>Redis</code> 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value。</strong></li>
</ul>
<h2 id="可以对数据做什么操作？"><a href="#可以对数据做什么操作？" class="headerlink" title="可以对数据做什么操作？"></a>可以对数据做什么操作？</h2><p><code>SimpleKV</code> 是一个简单的键值数据库，因此，基本操作无外乎增删改查。</p>
<ul>
<li>PUT：新写入或更新一个 key-value 对；</li>
<li>GET：根据一个 key 读取相应的 value 值；</li>
<li>DELETE：根据一个 key 删除整个 key-value 对。</li>
</ul>
<p>在实际的业务场景中，我们经常会碰到这种情况：查询一个用户在一段时间内的访问记录。这种操作在键值数据库中属于 SCAN 操作，即 <strong>根据一段 key 的范围返回相应的 value 值</strong> 。因此，<strong>PUT/GET/DELETE/SCAN 是一个键值数据库的基本操作集合。</strong></p>
<p>当一个键值数据库的 value 类型多样化时，就需要包含相应的操作接口。例如，<code>Redis</code> 的 value 有列表类型，因此它的接口就要包括对列表 value 的操作。</p>
<p><strong>键值对保存在内存还是外存？</strong></p>
<ul>
<li>保存在内存的好处是读写很快，毕竟内存的访问速度一般都在百 <code>ns</code> 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。</li>
<li>保存在外存，虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。</li>
</ul>
<p>如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景。比如，缓存场景下的数据需要能快速访问但允许丢失，那么，用于此场景的键值数据库通常采用内存保存键值数据。<code>Memcached</code> 和 <code>Redis</code> 都是属于内存键值数据库。对于 <code>Redis</code> 而言，缓存是非常重要的一个应用场景。</p>
<p>一个键值数据库包括了访问框架、索引模块、操作模块和存储模块四部分。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/ec18bf4b8afef2fa8b99af252d95a2d5.jpg" alt="img" style="zoom: 15%;" />

<h2 id="采用什么访问模式？"><a href="#采用什么访问模式？" class="headerlink" title="采用什么访问模式？"></a>采用什么访问模式？</h2><p>访问模式通常有两种：</p>
<ul>
<li>一种是 <strong>通过函数库调用的方式供外部应用使用</strong> ，比如，上图中的 <code>libsimplekv.so</code>，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；</li>
<li>另一种是 <strong>通过网络框架以 Socket 通信的形式对外提供键值对操作</strong> ，这种形式可以提供广泛的键值存储服务。在上图中，我们可以看到，网络框架中包括 Socket Server 和协议解析。</li>
</ul>
<h2 id="如何定位键值对的位置？"><a href="#如何定位键值对的位置？" class="headerlink" title="如何定位键值对的位置？"></a>如何定位键值对的位置？</h2><p>当 <code>SimpleKV</code> 解析了客户端发来的请求，知道了要进行的键值对操作，此时，<code>SimpleKV</code> 需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块。 <strong>索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作。</strong></p>
<p>索引的类型有很多，常见的有哈希表、B+ 树、字典树等。不同的索引结构在性能、空间消耗、并发控制等方面具有不同的特征。如果你看过其他键值数据库，就会发现，不同键值数据库采用的索引并不相同，例如，<code>Memcached</code> 和 <code>Redis</code> 采用哈希表作为 key-value 索引，而 <code>RocksDB</code> 则采用跳表作为内存中 key-value 的索引。</p>
<p>一般而言，内存键值数据库（例如 <code>Redis</code>）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表 O(1) 的操作复杂度相匹配。</p>
<p><code>SimpleKV</code> 的索引根据 key 找到 value 的存储位置即可。但是，和 <code>SimpleKV</code> 不同，对于 <code>Redis</code> 而言，很有意思的一点是，它的 value 支持多种类型，当我们通过索引找到一个 key 所对应的 value 后，仍然需要从 value 的复杂结构（例如集合和列表）中进一步找到我们实际需要的数据，这个操作的效率本身就依赖于它们的实现结构。</p>
<h2 id="不同操作的具体逻辑是怎样的？"><a href="#不同操作的具体逻辑是怎样的？" class="headerlink" title="不同操作的具体逻辑是怎样的？"></a>不同操作的具体逻辑是怎样的？</h2><ul>
<li>对于 GET/SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；</li>
<li>对于 PUT 一个新的键值对数据而言，<code>SimpleKV</code> 需要为该键值对分配内存空间；</li>
<li>对于 DELETE 操作，<code>SimpleKV</code> 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。</li>
</ul>
<h2 id="如何实现重启后快速提供服务？"><a href="#如何实现重启后快速提供服务？" class="headerlink" title="如何实现重启后快速提供服务？"></a>如何实现重启后快速提供服务？</h2><p><code>SimpleKV</code> 采用了常用的内存分配器 <code>glibc</code> 的 <code>malloc</code> 和 free，因此，<code>SimpleKV</code> 并不需要特别考虑内存空间的管理问题。但是，键值数据库的键值对通常大小不一，<code>glibc</code> 的分配器在处理随机的大小内存块分配时，表现并不好。一旦保存的键值对数据规模过大，就可能会造成较严重的内存碎片问题。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/30e0e0eb0b475e6082dd14e63c13ed44.jpg" alt="img" style="zoom:15%;" />

<p>从 <code>SimpleKV</code> 演进到 <code>Redis</code>，有以下几个重要变化：</p>
<ul>
<li><code>Redis</code> 主要通过网络框架进行访问，而不再是动态库了，这也使得 <code>Redis</code> 可以作为一个基础性的网络服务进行访问，扩大了 <code>Redis </code>的应用范围。</li>
<li><code>Redis</code> 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 <code>LPUSH/LPOP</code>，面向集合的 <code>SADD/SREM </code>等。在下节课，我将和你聊聊这些 value 模型背后的数据结构和操作效率，以及它们对 <code>Redis</code> 性能的影响。</li>
<li><code>Redis</code> 的持久化模块能支持两种方式：日志（<code>AOF</code>）和快照（<code>RDB</code>），这两种持久化方式具有不同的优劣势，影响到 <code>Redis</code> 的访问性能和可靠性。</li>
<li><code>SimpleKV</code> 是个简单的单机键值数据库，但是，<code>Redis</code> 支持高可靠集群和高可扩展集群，因此，<code>Redis</code> 中包含了相应的集群功能支撑模块。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>数据结构：快速的Redis有哪些慢操作？</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C%EF%BC%9F/</url>
    <content><![CDATA[<h1 id="数据结构：快速的Redis有哪些慢操作？"><a href="#数据结构：快速的Redis有哪些慢操作？" class="headerlink" title="数据结构：快速的Redis有哪些慢操作？"></a>数据结构：快速的<code>Redis</code>有哪些慢操作？</h1><p>底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/8219f7yy651e566d47cc9f661b399f01.jpg" alt="img" style="zoom:20%;" />

<p>可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型， <strong>它们的特点是一个键对应了一个集合的数据。</strong></p>
<ul>
<li>这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？</li>
<li>为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？</li>
<li>什么是简单动态字符串，和常用的字符串是一回事吗？</li>
</ul>
<span id="more"></span>

<h2 id="键和值用什么结构组织？"><a href="#键和值用什么结构组织？" class="headerlink" title="键和值用什么结构组织？"></a>键和值用什么结构组织？</h2><ul>
<li>为了实现从键到值的快速访问，<code>Redis</code> 使用了一个哈希表来保存所有键值对。</li>
<li>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。</li>
<li>哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。</li>
</ul>
<p>哈希桶中的 entry 元素中保存了<code>*key</code>和<code>*value</code>指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过<code>*value</code>指针被查找到。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/1cc8eaed5d1ca4e3cdbaa5a3d48dfb5f.jpg" alt="img" style="zoom:33%;" />

<p>因为这个哈希表保存了所有的键值对，所以，我也把它称为 <strong>全局哈希表</strong> 。哈希表的最大好处很明显，就是让我们可以用 O(1) 的时间复杂度来快速查找到键值对——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p>
<p>当你往 <code>Redis</code> 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点， <strong>那就是哈希表的冲突问题和 rehash 可能带来的操作阻塞。</strong></p>
<h2 id="为什么哈希表操作变慢了？"><a href="#为什么哈希表操作变慢了？" class="headerlink" title="为什么哈希表操作变慢了？"></a>为什么哈希表操作变慢了？</h2><p>这里的哈希冲突，也就是指，两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。哈希桶的个数通常要少于 key 的数量，难免会有一些 key 的哈希值对应到了同一个哈希桶中。</p>
<p><code>Redis</code> 解决哈希冲突的方式，就是链式哈希。 <strong>链式哈希也很容易理解，就是指同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接。</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/8ac4cc6cf94968a502161f85d072e428.jpg" alt="img" style="zoom: 33%;" />

<p><strong>存在问题：</strong> 哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。对于追求“快”的 <code>Redis</code> 来说，这是不太能接受的。</p>
<p>所以，<code>Redis</code> 会对哈希表做 rehash 操作。rehash 也就是增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。</p>
<p>为了使 rehash 操作更高效，<code>Redis</code> 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，<code>Redis</code> 开始执行 rehash，这个过程分为三步：</p>
<ol>
<li><p>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</p>
</li>
<li><p>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</p>
</li>
<li><p>释放哈希表 1 的空间。</p>
</li>
</ol>
<p>我们就可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。</p>
<p>这个过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 <code>Redis</code> <strong>线程阻塞</strong>，无法服务其他请求。此时，<code>Redis</code> 就无法快速访问数据了。</p>
<p>为了避免这个问题，<code>Redis</code> 采用了 <strong>渐进式 rehash</strong> 。</p>
<p>简单来说就是在第二步拷贝数据时，<code>Redis</code> 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries。</p>
<img src="https://static001.geekbang.org/resource/image/73/0c/73fb212d0b0928d96a0d7d6ayy76da0c.jpg" alt="img" style="zoom: 33%;" />

<p>这样就巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p>
<h2 id="集合数据操作效率"><a href="#集合数据操作效率" class="headerlink" title="集合数据操作效率"></a>集合数据操作效率</h2><p>和 String 类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。那么，集合的操作效率和哪些因素相关呢?</p>
<ul>
<li>首先，与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。</li>
<li>其次，操作效率和这些操作本身的执行特点有关，比如读写一个元素的操作要比读写所有元素的效率高。</li>
</ul>
<h2 id="有哪些底层数据结构？"><a href="#有哪些底层数据结构？" class="headerlink" title="有哪些底层数据结构？"></a>有哪些底层数据结构？</h2><p>集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。</p>
<p><strong>压缩列表</strong> 实际上类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 <code>zlbytes</code>、<code>zltail</code> 和 <code>zllen</code>，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p>
<img src="https://static001.geekbang.org/resource/image/95/a0/9587e483f6ea82f560ff10484aaca4a0.jpg" alt="img" style="zoom:33%;" />

<p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p>
<p><strong>跳表：</strong> 有序链表只能逐一查找元素，导致操作起来非常缓慢，于是就出现了跳表。具体来说，跳表在链表的基础上，增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位，如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/1e/b4/1eca7135d38de2yy16681c2bbc4f3fb4.jpg" alt="img" style="zoom:33%;" />

<p>当数据量很大时，跳表的查找复杂度就是 <code>O(logN)</code>。</p>
<img src="https://static001.geekbang.org/resource/image/fb/f0/fb7e3612ddee8a0ea49b7c40673a0cf0.jpg" alt="img" style="zoom:33%;" />

<h2 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h2><p>集合类型的操作类型很多，有读写单个集合元素的，例如 <code>HGET、HSET</code>，也有操作多个元素的，例如 <code>SADD</code>，还有对整个集合进行遍历操作的，例如 <code>SMEMBERS</code>。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是我们选择集合类型的重要依据。</p>
<ul>
<li>单元素操作是基础；</li>
<li>范围操作非常耗时；</li>
<li>统计操作通常高效；</li>
<li>例外情况只有几个。</li>
</ul>
<p>第一，单元素操作，是<strong>指每一种集合类型对单个数据实现的增删改查操作</strong>。例如，Hash 类型的 <code>HGET</code>、<code>HSET</code> 和 <code>HDEL</code>，Set 类型的 <code>SADD</code>、<code>SREM</code>、<code>SRANDMEMBER</code> 等。这些操作的复杂度由集合采用的数据结构决定，例如，<code>HGET</code>、<code>HSET</code> 和<code> HDEL</code> 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 <code>SADD</code>、<code>SREM</code>、<code>SRANDMEMBER</code> 复杂度也是 O(1)。</p>
<p>集合类型支持同时对多个元素进行增删改查，例如 Hash 类型的 <code>HMGET</code> 和 <code>HMSET</code>，Set 类型的 <code>SADD</code> 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，<code>HMSET</code> 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</p>
<p>第二，范围操作，是<strong>指集合类型中的遍历操作</strong>，可以返回集合中的所有数据，比如 Hash 类型的 <code>HGETALL</code> 和 Set 类型的 <code>SMEMBERS</code>，或者返回一个范围内的部分数据，比如 List 类型的 <code>LRANGE</code> 和 <code>ZSet</code> 类型的 <code>ZRANGE</code>。这类操作的复杂度一般是 O(N)，比较耗时，我们应该尽量避免。</p>
<p>第三，统计操作，是指集合类型对集合中所有元素个数的记录，例如 <code>LLEN</code> 和 <code>SCARD</code>。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p>
<p>第四，例外情况，是指某些数据结构的特殊记录，例如压缩列表和双向链表都会记录表头和表尾的偏移量。这样一来，对于 List 类型的 <code>LPOP、RPOP、LPUSH、RPUSH</code> 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>整数数组和压缩列表在查找时间复杂度方面并没有很大的优势，那为什么<code> Redis</code> 还会把它们作为底层数据结构呢？</p>
<ul>
<li>内存利用率，数组和压缩列表都是非常紧凑的数据结构，它比链表占用的内存要更少。<code>Redis</code>是内存数据库，大量数据存到内存中，此时需要做尽可能的优化，提高内存的利用率。</li>
<li>数组对CPU高速缓存支持更友好，所以<code>Redis</code>在设计时，集合数据元素较少情况下，默认采用内存紧凑排列的方式存储，同时利用CPU高速缓存不会降低访问速度。当数据元素超过设定阈值后，避免查询时间复杂度太高，转为哈希和跳表数据结构存储，保证查询效率。</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>二叉树</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b7043bf29a253bb36221eaec62b2e129.jpg" alt="img" style="zoom:50%;" />

<span id="more"></span>

<p>这里面每个元素我们叫做“节点”；用来连接相邻节点之间的关系，我们叫做“父子关系”。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/220043e683ea33b9912425ef759556ae.jpg" alt="img"></p>
<p>A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p>
<p><strong>高度（Height）、深度（Depth）、层（Level</strong>）：</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4094a733986073fedb6b9d03f877d71e.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="img"></p>
<ul>
<li>高度：从下往上度量，从最底层开始计数，并且计数的起点是 0。</li>
<li>深度：从上往下度量，从根结点开始度量，并且计数起点也是 0。</li>
<li>层数：跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330162407118.png" alt="image-20210330162407118"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/18413c6597c2850b75367393b401ad60.jpg" alt="img"></p>
<h3 id="如何存储二叉树？"><a href="#如何存储二叉树？" class="headerlink" title="如何存储二叉树？"></a>如何存储二叉树？</h3><ul>
<li><p>基于指针或者引用的二叉链式存储法</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="img"></p>
</li>
<li><p>基于数组的顺序存储法。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/14eaa820cb89a17a7303e8847a412330.jpg" alt="img"></p>
</li>
</ul>
<p>如果节点 X 存储在数组中下标为 <code>i </code>的位置，下标为 <code>2 * i</code> 的位置存储的就是左子节点，下标为 <code>2 * i + 1</code> 的位置存储的就是右子节点。反过来，下标为 <code>i/2</code> 的位置存储就是它的父节点。</p>
<p><strong>完全二叉树：</strong> 如果某棵二叉树是一棵完全二叉树，那用 <strong>数组</strong> 存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
</li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
</li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
</li>
<li><p>层序遍历：利用队列来依次打印每一层的元素值。</p>
</li>
<li><p>时间复杂度：<code>O(n)</code></p>
</li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/ab103822e75b5b15c615b68560cb2416.jpg" alt="img"></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f3bb11b6d4a18f95aa19e11f22b99bae.jpg" alt="img"></p>
<h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><ul>
<li>先取根节点，如果它等于我们要查找的数据，那就返回。</li>
<li>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</li>
<li>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/96b3d86ed9b7c4f399e8357ceed0db2a.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binarySearchTree::isInBST</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInBST</span>(root-&gt;left, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入"></a>2.插入</h3><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<ul>
<li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
</li>
<li><p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/daa9fb557726ee6183c5b80222cfc5c5.jpg" alt="img"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">binarySearchTree::insertIntoBST</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h3><p>框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (roo-&gt;val &gt; key) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 1</strong> ：删除节点恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330165915530.png" alt="image-20210330165915530"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == null &amp;&amp; root-&gt;right == null)</span><br><span class="line">    <span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 2</strong>：删除节点只有一个非空子节点，那么它要让这个孩子接替自己的位置。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330170032244.png" alt="image-20210330170032244"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == null) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right == null) <span class="keyword">return</span> root-&gt;left;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 3</strong> ： 删除有两个子节点，麻烦了，为了不破坏 <code>BST</code> 的性质，必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。以第二种方式讲解。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330170203285.png" alt="image-20210330170203285"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != null &amp;&amp; root-&gt;right != null) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root-&gt;val = minNode-&gt;val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下，这个删除操作并不完美，因为我们一般不会通过 <code>root-&gt;val = minNode-&gt;val</code> 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p>
<h3 id="4-支持重复数据的二叉查找树"><a href="#4-支持重复数据的二叉查找树" class="headerlink" title="4.支持重复数据的二叉查找树"></a>4.支持重复数据的二叉查找树</h3><p>前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。 <strong>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？</strong></p>
<ul>
<li><p>第一种方法：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
</li>
<li><p>第二种方法：每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg" alt="img"></p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<p><img src="https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg" alt="img"></p>
<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
<p><img src="https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg" alt="img"></p>
<h3 id="5-二叉查找树的时间复杂度分析"><a href="#5-二叉查找树的时间复杂度分析" class="headerlink" title="5.二叉查找树的时间复杂度分析"></a>5.二叉查找树的时间复杂度分析</h3><p>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<p><img src="https://static001.geekbang.org/resource/image/e3/d9/e3d9b2977d350526d2156f01960383d9.jpg" alt="img"></p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？树的高度就等于最大层数减一，为了方便计算，我们转换成层来表</p>
<p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p>
<p><strong>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n &gt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L<span class="number">-2</span>)+<span class="number">1</span></span><br><span class="line">n &lt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L<span class="number">-2</span>)+<span class="number">2</span>^(L<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>借助等比数列的求和公式，我们可以计算出，L 的范围是<code>[log2(n+1), log2n +1]</code>。完全二叉树的层数小于等于 <code>log2n +1</code>，也就是说，完全二叉树的高度小于等于<code> log2n</code>。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/9b/dd9f5a4525f5029a8339c89ad1c8159b.jpg" alt="img"></p>
<p>最先被发明的平衡二叉查找树是<code>AVL</code>树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p>
<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树， <strong>它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</strong></p>
<p><strong>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</strong></p>
<p><strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</strong></p>
<p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比<code>log2n</code> 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，</p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的，下一节我们讲红黑树的实现的时候会讲到。这节我们暂时不考虑这一点，所以，在画图和讲解的时候，我将黑色的、空的叶子节点都省略掉了。</p>
<p><img src="https://static001.geekbang.org/resource/image/90/9a/903ee0dcb62bce2f5b47819541f9069a.jpg" alt="img"></p>
<h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>algorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>栈</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h2><p><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong>栈是一种<strong>“操作受限”</strong>的线性表，只允许在一端插入和删除数据。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313172646.jpeg" alt="img" style="zoom:50%;" />

<span id="more"></span>

<h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<ul>
<li><p>空间复杂度：我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以**空间复杂度是 O(1)**。</p>
</li>
<li><p>时间复杂度：时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以**时间复杂度都是 O(1)**。</p>
</li>
</ul>
<p><strong>支持动态扩容的顺序栈</strong></p>
<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313173357.jpeg" alt="img" style="zoom:50%;" />

<ul>
<li><strong>出栈时间复杂度</strong>：对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。</li>
<li><strong>入栈时间复杂度：</strong>对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<strong>最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)，平均情况下的时间复杂度为O(1)</strong></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p><strong>栈在函数调用中的应用</strong></p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
</li>
<li><p><strong>栈在表达式求值中的应用</strong></p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174152.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p><strong>栈在括号匹配中的应用</strong></p>
<p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
</li>
<li><p><strong>如何实现浏览器的前进和后退功能</strong></p>
<p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<ul>
<li><p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174508.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174527.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174548.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174616.jpeg" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li><p><strong>讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</strong></p>
<p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p>
<p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>链表</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="链表（上）"><a href="#链表（上）" class="headerlink" title="链表（上）"></a>链表（上）</h1><h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><ul>
<li><p>数组需要一块 <strong>连续</strong> 的内存空间来存储，链表恰恰相反，它并 <strong>不需要一块连续</strong> 的内存空间，它通过“指针”将一组零散的内存块串联起来使用。</p>
<span id="more"></span>

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210324155924249.png" alt="image-20210324155924249" style="zoom: 50%;" /></li>
<li><p> <strong>链表类型：</strong> 单链表、双向链表和循环链表。</p>
</li>
<li><p><strong>单链表：</strong> 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的<strong>“结点”</strong>。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom:50%;" />

<ul>
<li><strong>插入，删除：</strong> 只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</li>
</ul>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/452e943788bdeea462d364389bd08a17.jpg" alt="img" style="zoom: 50%;" />

<ul>
<li><strong>查找：</strong> 根据指针一个结点一个结点地依次遍历，直到找到相应的结点，<strong>需要 O(n) 的时间复杂度。</strong></li>
</ul>
</li>
<li><p><strong>循环链表：</strong> 循环链表的尾结点指针是指向链表的头结点。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/86cb7dc331ea958b0a108b911f38d155.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>优点：循环链表的优点是从链尾到链头比较方便。当要处理的数据<strong>具有环型结构特点</strong>时，就特别适合采用循环链表。</li>
</ul>
</li>
<li><p><strong>双向链表：</strong> 支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 <code>prev</code> 指向前面的结点。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性，<strong>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点</strong>，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</li>
</ul>
</li>
<li><p><strong>双向循环链表：</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104205.jpeg" alt="img" style="zoom: 50%;" /></li>
<li><p><strong>链表的删除操作：</strong>双向链表的优势</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点：<ul>
<li>不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。<strong>删除O(1)，查找O(n)，总时间复杂度为O(n)</strong></li>
</ul>
</li>
<li>删除给定指针指向的结点：<ul>
<li>我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</li>
<li>因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</li>
<li>插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h2><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104247.jpeg" alt="img" style="zoom:50%;" />

<h1 id="链表（下）"><a href="#链表（下）" class="headerlink" title="链表（下）"></a>链表（下）</h1><p>写链表代码注意的问题：</p>
<ul>
<li><p><strong>理解指针或引用的含义</strong></p>
</li>
<li><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
</li>
<li><p><strong>警惕指针丢失和内存泄漏</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104919.jpeg" alt="img" style="zoom:50%;" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x-&gt;next = b;</span><br><span class="line">a-&gt;next = x;</span><br></pre></td></tr></table></figure>

<p>删除链表结点时，也一定要记得手动释放内存空间。</p>
<ul>
<li><p><strong>利用哨兵简化实现难度</strong></p>
<ul>
<li><p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</p>
</li>
<li><p>如果我们引入 <strong>哨兵结点</strong> ，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313105116.jpeg" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>重点留意边界条件处理</strong></p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
</li>
</ul>
<p><strong>必会代码：</strong></p>
<ul>
<li>实现单链表、循环链表、双向链表，支持增删操作</li>
<li>实现单链表反转</li>
<li>实现两个有序的链表合并为一个有序链表</li>
<li>实现求链表的中间结点</li>
<li>链表中环的检测</li>
<li>删除链表倒数第 n 个结点</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Redis并发问题</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="无锁的原子操作：Redis如何应对并发访问？"><a href="#无锁的原子操作：Redis如何应对并发访问？" class="headerlink" title="无锁的原子操作：Redis如何应对并发访问？"></a>无锁的原子操作：Redis如何应对并发访问？</h1><p>为了保证并发访问的正确性，Redis 提供了两种方法，分别是加锁和原子操作。</p>
<ul>
<li><p><strong>加锁：</strong> 加锁是一种常用的方法，在读取数据前，客户端需要先获得锁，否则就无法进行操作。当一个客户端获得锁后，就会一直持有这把锁，直到客户端完成数据更新，才释放这把锁。</p>
<p><strong>弊端：</strong> 1. 如果加锁操作多，会降低系统的并发访问性能；</p>
<p>​             2. 第二个是，Redis 客户端要加锁时，需要用到分布式锁，而分布式锁实现复杂，需要用额外的存储系统来提供加解锁操作</p>
</li>
<li><p><strong>原子操作：</strong> 原子操作是指执行过程保持原子性的操作，而且原子操作执行时并不需要再加锁，实现了无锁操作。这样一来，既能保证并发控制，还能减少对系统并发性能的影响。</p>
</li>
</ul>
<h2 id="并发访问中需要对什么进行控制？"><a href="#并发访问中需要对什么进行控制？" class="headerlink" title="并发访问中需要对什么进行控制？"></a>并发访问中需要对什么进行控制？</h2><p>我们说的并发访问控制，是指对多个客户端访问操作同一份数据的过程进行控制，以保证任何一个客户端发送的操作在 Redis 实例上执行时具有互斥性。例如，客户端 A 的访问操作在执行时，客户端 B 的操作不能执行，需要等到 A 的操作结束后，才能执行。</p>
<p>并发访问控制对应的操作主要是数据修改操作。当客户端需要修改数据时，基本流程分成两步：</p>
<ul>
<li><p>客户端先把数据读取到本地，在本地进行修改；</p>
</li>
<li><p>客户端修改完数据后，再写回 Redis。</p>
</li>
</ul>
<p>我们把这个流程叫做“读取 - 修改 - 写回”操作（Read-Modify-Write，简称为 RMW 操作）。当有多个客户端对同一份数据执行 RMW 操作的话，我们就需要让 RMW 操作涉及的代码以原子性方式执行。访问同一份数据的 RMW 操作代码，就叫做临界区代码。</p>
<p>假设客户端要对商品库存执行扣减 1 的操作，伪代码如下所示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">current = GET(id)</span><br><span class="line">current--</span><br><span class="line">SET(id, current)</span><br></pre></td></tr></table></figure>

<img src="https://static001.geekbang.org/resource/image/dc/5c/dce821cd00c1937b4aab1f130424335c.jpg" alt="img" style="zoom:18%;" />

<p>为了保证数据并发修改的正确性，我们可以用锁把并行操作变成串行操作，串行操作就具有互斥性。一个客户端持有锁后，其他客户端只能等到锁释放，才能拿锁再进行修改。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">LOCK</span>()</span><br><span class="line">current = <span class="built_in">GET</span>(id)</span><br><span class="line">current--</span><br><span class="line"><span class="built_in">SET</span>(id, current)</span><br><span class="line"><span class="built_in">UNLOCK</span>()</span><br></pre></td></tr></table></figure>

<p><strong>虽然加锁保证了互斥性，但是加锁也会导致系统并发性能降低。</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/845b4694700264482d64a3dbb7a36525.jpg" alt="img" style="zoom:18%;" />

<h2 id="Redis-的两种原子操作方法"><a href="#Redis-的两种原子操作方法" class="headerlink" title="Redis 的两种原子操作方法"></a>Redis 的两种原子操作方法</h2><ul>
<li>把多个操作在 Redis 中实现成一个操作，也就是单命令操作；</li>
<li>把多个操作写到一个 Lua 脚本中，以原子性方式执行单个 Lua 脚本。</li>
</ul>
<h3 id="单命令操作"><a href="#单命令操作" class="headerlink" title="单命令操作"></a>单命令操作</h3><p>Redis 是使用单线程来串行处理客户端的请求操作命令的，所以，当 Redis 执行某个命令操作时，其他命令是无法执行的，这相当于命令操作是互斥执行的。当然，Redis 的快照生成、AOF 重写这些操作，可以使用后台线程或者是子进程执行，也就是和主线程的操作并行执行。不过，这些操作只是读取数据，不会修改数据，所以，我们并不需要对它们做并发控制。</p>
<p>虽然 Redis 的单个命令操作可以原子性地执行，但是在实际应用中，数据修改时可能包含多个操作，至少包括读数据、数据增减、写回数据三个操作，这显然就不是单个命令操作了，那该怎么办呢？</p>
<p>Redis 提供了 INCR/DECR 命令，把这三个操作转变为一个原子操作了。INCR/DECR 命令可以对数据进行增值 / 减值操作，而且它们本身就是单个命令操作，Redis 在执行它们时，本身就具有互斥性。</p>
<p>比如说，在刚才的库存扣减例子中，客户端可以使用下面的代码，直接完成对商品 id 的库存值减 1 操作。即使有多个客户端执行下面的代码，也不用担心出现库存值扣减错误的问题。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">DECR id </span><br></pre></td></tr></table></figure>

<p>但是，如果我们要执行的操作不是简单地增减数据，而是有更加复杂的判断逻辑或者是其他操作，那么，Redis 的单命令操作已经无法保证多个操作的互斥执行了。所以，这个时候，我们需要使用第二个方法，也就是 Lua 脚本。</p>
<h3 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h3><p>Redis 会把整个 Lua 脚本作为一个整体执行，在执行的过程中不会被其他命令打断，从而保证了 Lua 脚本中操作的原子性。如果我们有多个操作要执行，但是又无法用 INCR/DECR 这种命令操作来实现，就可以把这些要执行的操作编写到一个 Lua 脚本中。然后，我们可以使用 Redis 的 EVAL 命令来执行脚本。这样一来，这些操作在执行时就具有了互斥性。</p>
<p>假设我们编写的脚本名称为 lua.script，我们接着就可以使用 Redis 客户端，带上 eval 选项，来执行该脚本。脚本所需的参数将通过以下命令中的 keys 和 args 进行传递。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">redis-cli  --eval lua.script  keys , args</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>对于编写lua脚本应该注意什么</p>
<ul>
<li>对读操作不需要进行并发控制</li>
<li>减少lua 脚本中的命令，可以降低Redis执行脚本的时间，避免阻塞 Redis。</li>
<li>lua 脚本尽量只编写通用的逻辑代码，避免直接写死变量。变量通过外部调用方传递进来，这样 lua 脚本的可复用度更高。</li>
<li>建议先使用SCRIPT LOAD命令把 lua 脚本加载到 Redis 中，然后得到一个脚本唯一摘要值，再通过EVALSHA命令 + 脚本摘要值来执行脚本，这样可以避免每次发送脚本内容到 Redis，减少网络开销。</li>
</ul>
<h1 id="如何使用Redis实现分布式锁？"><a href="#如何使用Redis实现分布式锁？" class="headerlink" title="如何使用Redis实现分布式锁？"></a>如何使用Redis实现分布式锁？</h1><p>Redis 属于分布式系统，当有多个客户端需要争抢锁时，我们必须要保证，这<strong>把锁不能是某个客户端本地的锁</strong>。否则的话，其它客户端是无法访问这把锁的，当然也就不能获取这把锁了。</p>
<p><strong>所以，在分布式系统中，当有多个客户端需要获取锁时，我们需要分布式锁。此时，锁是保存在一个共享存储系统中的，可以被多个客户端共享访问和获取。</strong></p>
<p>Redis 本身可以被多个客户端共享访问，正好就是一个共享存储系统，可以用来保存分布式锁。而且 Redis 的读写性能高，可以应对高并发的锁操作场景。</p>
<h2 id="单机上的锁和分布式锁的联系与区别"><a href="#单机上的锁和分布式锁的联系与区别" class="headerlink" title="单机上的锁和分布式锁的联系与区别"></a>单机上的锁和分布式锁的联系与区别</h2><p>对于在单机上运行的多线程程序来说，锁本身可以用一个变量表示。</p>
<ul>
<li>变量值为 0 时，表示没有线程获取锁；</li>
<li>变量值为 1 时，表示已经有线程获取到锁了。</li>
</ul>
<p>我们通常说的线程调用加锁和释放锁的操作，到底是啥意思呢？我来解释一下。实际上，一个线程调用加锁操作，其实就是检查锁变量值是否为 0。如果是 0，就把锁的变量值设置为 1，表示获取到锁，如果不是 0，就返回错误信息，表示加锁失败，已经有别的线程获取到锁了。而一个线程调用释放锁操作，其实就是将锁变量的值置为 0，以便其它线程可以来获取锁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">acquire_lock</span>()&#123;</span><br><span class="line">  <span class="keyword">if</span> lock == <span class="number">0</span></span><br><span class="line">     lock = <span class="number">1</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="built_in">release_lock</span>()&#123;</span><br><span class="line">  lock = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分布式锁同样可以用<strong>一个变量来实现</strong>： <strong>加锁时同样需要判断锁变量的值，根据锁变量值来判断能否加锁成功；释放锁时需要把锁变量值设置为 0，表明客户端不再持有锁。</strong> 锁变量需要由一个共享存储系统来维护，只有这样，多个客户端才可以通过访问共享存储系统来访问锁变量。相应的，<strong>加锁和释放锁的操作就变成了读取、判断和设置共享存储系统中的锁变量值。</strong></p>
<p><strong>实现分布式锁的两个要求：</strong></p>
<ul>
<li>要求一：分布式锁的加锁和释放锁的过程，涉及多个操作。所以，在实现分布式锁时，我们需要保证这些锁操作的原子性；</li>
<li>要求二：共享存储系统保存了锁变量，如果共享存储系统发生故障或宕机，那么客户端也就无法进行锁操作了。在实现分布式锁时，我们需要考虑保证共享存储系统的可靠性，进而保证锁的可靠性。</li>
</ul>
<h2 id="基于单个-Redis-节点实现分布式锁"><a href="#基于单个-Redis-节点实现分布式锁" class="headerlink" title="基于单个 Redis 节点实现分布式锁"></a>基于单个 Redis 节点实现分布式锁</h2><p>作为分布式锁实现过程中的共享存储系统，Redis 可以使用键值对来保存锁变量，再接收和处理不同客户端发送的加锁和释放锁的操作请求。那么，键值对的键和值具体是怎么定的呢？</p>
<p>我们要赋予锁变量一个变量名，把这个变量名作为键值对的键，而锁变量的值，则是键值对的值，这样一来，Redis 就能保存锁变量了，客户端也就可以通过 Redis 的命令操作来实现锁操作。</p>
<img src="https://static001.geekbang.org/resource/image/1d/45/1d18742c1e5fc88835ec27f1becfc145.jpg?wh=2820*2250" alt="img" style="zoom:18%;" />

<p>处理过程：</p>
<p><strong>加锁：</strong>在图中，客户端 A 和 C 同时请求加锁。因为 Redis 使用单线程处理请求，所以，即使客户端 A 和 C 同时把加锁请求发给了 Redis，Redis 也会串行处理它们的请求。我们假设 Redis 先处理客户端 A 的请求，读取 lock_key 的值，发现 lock_key 为 0，所以，Redis 就把 lock_key 的 value 置为 1，表示已经加锁了。紧接着，Redis 处理客户端 C 的请求，此时，Redis 会发现 lock_key 的值已经为 1 了，所以就返回加锁失败的信息。</p>
<p><strong>释放锁：</strong> 当客户端 A 持有锁时，锁变量 lock_key 的值为 1。客户端 A 执行释放锁操作后，Redis 将 lock_key 的值置为 0，表明已经没有客户端持有锁了。</p>
<img src="https://static001.geekbang.org/resource/image/c7/82/c7c413b47d42f06f08fce92404f31e82.jpg?wh=3000*2250" alt="img" style="zoom:18%;" />

<p>因为加锁包含了三个操作（读取锁变量、判断锁变量值以及把锁变量值设置为 1），而这三个操作在执行时需要保证原子性。<strong>那怎么保证原子性呢？</strong></p>
<ul>
<li>单命令操作：<ul>
<li>SETNX：它用于设置键值对的值。具体来说，就是这个命令在执行时会判断键值对是否存在，如果不存在，就设置键值对的值，如果存在，就不做任何设置。</li>
<li>DEL 命令删除锁变量。不过，你不用担心锁变量被删除后，其他客户端无法请求加锁了。因为 SETNX 命令在执行时，如果要设置的键值对（也就是锁变量）不存在，SETNX 命令会先创建键值对，然后设置它的值。所以，释放锁之后，再有客户端请求加锁时，SETNX 命令会创建保存锁变量的键值对，并设置锁变量的值，完成加锁。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加锁</span></span><br><span class="line">SETNX lock_key <span class="number">1</span></span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line">DO THINGS</span><br><span class="line"><span class="comment">// 释放锁</span></span><br><span class="line">DEL lock_key</span><br></pre></td></tr></table></figure>

<p><strong>弊端：</strong> </p>
<ol>
<li><p>假如某个客户端在执行了 SETNX 命令、加锁之后，紧接着<strong>却在操作共享数据时发生了异常</strong>，结果一直没有执行最后的 DEL 命令释放锁。因此，锁就一直被这个客户端持有，其它客户端无法拿到锁，也无法访问共享数据和执行后续操作，这会给业务应用带来影响。</p>
<p><strong>解决：</strong> <strong>给锁变量设置一个过期时间</strong>。这样一来，即使持有锁的客户端发生了异常，无法主动地释放锁，Redis 也会根据锁变量的过期时间，在锁变量过期后，把它删除。其它客户端在锁变量过期后，就可以重新请求加锁，这就不会出现无法加锁的问题了。</p>
</li>
<li><p>如果客户端 A 执行了 SETNX 命令加锁后，假设客户端 B 执行了 DEL 命令释放锁，此时，客户端 A 的锁就被误释放了。如果客户端 C 正好也在申请加锁，就可以成功获得锁，<strong>进而开始操作共享数据</strong>。这样一来，客户端 A 和 C 同时在对共享数据进行操作，数据就会被修改错误，这也是业务层不能接受的。</p>
<p><strong>解决：</strong> 我们需要能区分来自不同客户端的锁操作，具体咋做呢？其实，我们可以在锁变量的值上想想办法。</p>
<p>在使用 SETNX 命令进行加锁的方法中，我们通过把锁变量值设置为 1 或 0，表示是否加锁成功。1 和 0 只有两种状态，无法表示究竟是哪个客户端进行的锁操作。所以，我们在加锁操作时，可以让每个客户端给锁变量设置一个唯一值，这里的唯一值就可以用来标识当前操作的客户端。在释放锁操作时，客户端需要判断，当前锁变量的值是否和自己的唯一标识相等，只有在相等的情况下，才能释放锁。这样一来，就不会出现误释放锁的问题了。</p>
<p><strong>Redis具体怎么实现：</strong></p>
<p>Redis 给 SET 命令提供了类似的选项 NX，用来实现“不存在即设置”。如果使用了 NX 选项，SET 命令只有在键值对不存在时，才会进行设置，否则不做赋值操作。此外，SET 命令在执行时还可以带上 EX 或 PX 选项，用来设置键值对的过期时间。</p>
<p>举个例子，执行下面的命令时，只有 key 不存在时，SET 才会创建 key，并对 key 进行赋值。另外，key 的存活时间由 seconds 或者 milliseconds 选项值来决定。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SET key value [EX seconds | PX milliseconds]  [NX]</span><br></pre></td></tr></table></figure>

<p>有了 SET 命令的 NX 和 EX/PX 选项后，我们就可以用下面的命令来实现加锁操作了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 加锁, unique_value作为客户端唯一性的标识</span><br><span class="line">SET lock_key unique_value NX PX 10000</span><br></pre></td></tr></table></figure>

<p>其中，unique_value 是客户端的唯一标识，可以用一个随机生成的字符串来表示，PX 10000 则表示 lock_key 会在 10s 后过期，以免客户端在这期间发生异常而无法释放锁。</p>
<p>因为在加锁操作中，每个客户端都使用了一个唯一标识，所以在释放锁操作时，我们需要判断锁变量的值，是否等于执行释放锁操作的客户端的唯一标识，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//释放锁 比较unique_value是否相等，避免误释放</span></span><br><span class="line"><span class="keyword">if</span> redis.<span class="built_in">call</span>(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] then</span><br><span class="line">    <span class="keyword">return</span> redis.<span class="built_in">call</span>(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>这是使用 Lua 脚本（unlock.script）实现的释放锁操作的伪代码，其中，KEYS[1]表示 lock_key，ARGV[1]是当前客户端的唯一标识，这两个值都是我们在执行 Lua 脚本时作为参数传入的。最后，我们执行下面的命令，就可以完成锁释放操作了。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">redis-cli  --eval  unlock.script lock_key , unique_value </span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>我们现在只用了一个 Redis 实例来保存锁变量，如果这个 Redis 实例发生故障宕机了，那么锁变量就没有了。此时，客户端也无法进行锁操作了，这就会影响到业务的正常执行。所以，我们在实现分布式锁时，还需要保证锁的可靠性。那怎么提高呢？这就要提到基于多个 Redis 节点实现分布式锁的方式了。</strong></p>
<h2 id="基于多个-Redis-节点实现高可靠的分布式锁"><a href="#基于多个-Redis-节点实现高可靠的分布式锁" class="headerlink" title="基于多个 Redis 节点实现高可靠的分布式锁"></a>基于多个 Redis 节点实现高可靠的分布式锁</h2><p>为了避免 Redis 实例故障而导致的锁无法工作的问题，Redis 的开发者 Antirez 提出了分布式锁算法 Redlock。</p>
<p><strong>Redlock 算法的基本思路</strong>，是让客户端和多个独立的 Redis 实例依次请求加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁了，否则加锁失败。这样一来，即使有单个 Redis 实例发生故障，因为锁变量在其它实例上也有保存，所以，客户端仍然可以正常地进行锁操作，锁变量并不会丢失。</p>
<p>Redlock 算法的实现需要有 N 个独立的 Redis 实例。接下来，我们可以分成 3 步来完成加锁操作。</p>
<p><strong>第一步是，客户端获取当前时间。</strong></p>
<p><strong>第二步是，客户端按顺序依次向 N 个 Redis 实例执行加锁操作。</strong></p>
<p>这里的加锁操作和在单实例上执行的加锁操作一样，使用 SET 命令，带上 NX，EX/PX 选项，以及带上客户端的唯一标识。当然，如果某个 Redis 实例发生故障了，为了保证在这种情况下，Redlock 算法能够继续运行，我们需要给加锁操作设置一个超时时间。</p>
<p>如果客户端在和一个 Redis 实例请求加锁时，一直到超时都没有成功，那么此时，客户端会和下一个 Redis 实例继续请求加锁。加锁操作的超时时间需要远远地小于锁的有效时间，一般也就是设置为几十毫秒。</p>
<p><strong>第三步是，一旦客户端完成了和所有 Redis 实例的加锁操作，客户端就要计算整个加锁过程的总耗时。</strong></p>
<p>客户端只有在满足下面的这两个条件时，才能认为是加锁成功。</p>
<ul>
<li>条件一：客户端从超过半数（大于等于 N/2+1）的 Redis 实例上成功获取到了锁；</li>
<li>条件二：客户端获取锁的总耗时没有超过锁的有效时间。</li>
</ul>
<p>在满足了这两个条件后，我们需要重新计算这把锁的有效时间，计算的结果是锁的最初有效时间减去客户端为获取锁的总耗时。如果锁的有效时间已经来不及完成共享数据的操作了，我们可以释放锁，以免出现还没完成数据操作，锁就过期了的情况。</p>
<p>当然，如果客户端在和所有实例执行完加锁操作后，没能同时满足这两个条件，那么，客户端向所有 Redis 节点发起释放锁的操作。</p>
<p>在 Redlock 算法中，释放锁的操作和在单实例上释放锁的操作一样，只要执行释放锁的 Lua 脚本就可以了。这样一来，只要 N 个 Redis 实例中的半数以上实例能正常工作，就能保证分布式锁的正常工作了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在基于单个 Redis 实例实现分布式锁时，对于加锁操作，我们需要满足三个条件。</p>
<ol>
<li><p>加锁包括了读取锁变量、检查锁变量值和设置锁变量值三个操作，但需要以原子操作的方式完成，所以，我们使用 SET 命令带上 NX 选项来实现加锁；</p>
</li>
<li><p>锁变量需要设置过期时间，以免客户端拿到锁后发生异常，导致锁一直无法释放，所以，我们在 SET 命令执行时加上 EX/PX 选项，设置其过期时间；</p>
</li>
<li><p>锁变量的值需要能区分来自不同客户端的加锁操作，以免在释放锁时，出现误释放操作，所以，我们使用 SET 命令设置锁变量值时，每个客户端设置的值是一个唯一值，用于标识客户端。</p>
<p>和加锁类似，释放锁也包含了读取锁变量值、判断锁变量值和删除锁变量三个操作，不过，我们无法使用单个命令来实现，所以，我们可以采用 Lua 脚本执行释放锁操作，通过 Redis 原子性地执行 Lua 脚本，来保证释放锁操作的原子性。</p>
<p>不过，基于单个 Redis 实例实现分布式锁时，会面临实例异常或崩溃的情况，这会导致实例无法提供锁操作，正因为此，Redis 也提供了 Redlock 算法，用来实现基于多个实例的分布式锁。这样一来，锁变量由多个实例维护，即使有实例发生了故障，锁变量仍然是存在的，客户端还是可以完成锁操作。Redlock 算法是实现高可靠分布式锁的一种有效解决方案，你可以在实际应用中把它用起来。</p>
</li>
</ol>
<h1 id="事务机制：Redis能实现ACID属性吗？"><a href="#事务机制：Redis能实现ACID属性吗？" class="headerlink" title="事务机制：Redis能实现ACID属性吗？"></a>事务机制：Redis能实现ACID属性吗？</h1><p>所谓的事务，就是指对数据进行读写的一系列操作。事务在执行时，会提供专门的属性保证，包括原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），也就是 ACID 属性。这些属性既包括了对事务执行结果的要求，也有对数据库在事务执行前后的数据状态变化的要求。</p>
<h2 id="事务-ACID-属性的要求"><a href="#事务-ACID-属性的要求" class="headerlink" title="事务 ACID 属性的要求"></a>事务 ACID 属性的要求</h2><ul>
<li><strong>原子性：</strong> 就是一个事务中的多个操作必须都完成，或者都不完成。</li>
<li><strong>一致性：</strong> 指数据库中的数据在事务执行前后是一致的。</li>
<li><strong>隔离性：</strong> 它要求数据库在执行一个事务时，其它操作无法存取到正在执行事务访问的数据。</li>
<li><strong>持久性：</strong> 数据库执行事务后，数据的修改要被持久化保存下来。当数据库重启后，数据的值需要是被修改后的值。 </li>
</ul>
<h2 id="Redis-如何实现事务？"><a href="#Redis-如何实现事务？" class="headerlink" title="Redis 如何实现事务？"></a>Redis 如何实现事务？</h2><p>事务的执行过程包含三个步骤，Redis 提供了 MULTI、EXEC 两个命令来完成这三个步骤。</p>
<ul>
<li>第一步，客户端要使用一个命令显式地表示一个事务的开启。在 Redis 中，这个命令就是 MULTI。</li>
<li>第二步，客户端把事务中本身要执行的具体操作（例如增删改数据）发送给服务器端。这些操作就是 Redis 本身提供的数据读写命令，例如 GET、SET 等。不过，这些命令虽然被客户端发送到了服务器端，但 Redis 实例只是把这些命令暂存到一个命令队列中，并不会立即执行。</li>
<li>第三步，客户端向服务器端发送提交事务的命令，让数据库实际执行第二步中发送的具体操作。Redis 提供的 EXEC 命令就是执行事务提交的。当服务器端收到 EXEC 命令后，才会实际执行命令队列中的所有命令。</li>
</ul>
<p>举例：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; MULTI</span><br><span class="line">OK</span><br><span class="line">#将a:stock减<span class="number">1</span>，</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR a:stock</span><br><span class="line">QUEUED</span><br><span class="line">#将b:stock减<span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; DECR b:stock</span><br><span class="line">QUEUED</span><br><span class="line">#实际执行事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span>&gt; EXEC</span><br><span class="line"><span class="number">1</span>) (integer) <span class="number">4</span></span><br><span class="line"><span class="number">2</span>) (integer) <span class="number">9</span></span><br></pre></td></tr></table></figure>



<h2 id="Redis-的事务机制能保证哪些属性？"><a href="#Redis-的事务机制能保证哪些属性？" class="headerlink" title="Redis 的事务机制能保证哪些属性？"></a>Redis 的事务机制能保证哪些属性？</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><ul>
<li><p><strong>第一种情况：</strong>在执行 EXEC 命令前，客户端发送的操作命令本身就有错误（比如语法错误，使用了不存在的命令），在命令入队时就被 Redis 实例判断出来了。对于这种情况，在命令入队时，Redis 就会报错并且记录下这个错误。此时，我们还能继续提交命令操作。等到执行了 EXEC 命令之后，Redis 就会拒绝执行所有提交的命令操作，返回事务失败的结果。这样一来，事务中的所有命令都不会再被执行了，<strong>保证了原子性。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> MULTI</span><br><span class="line">OK</span><br><span class="line">#发送事务中的第一个操作，但是Redis不支持该命令，返回报错信息</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> PUT a:stock <span class="number">5</span></span><br><span class="line">(error) ERR <span class="literal">unknown</span> command `PUT`, <span class="keyword">with</span> args beginning <span class="keyword">with</span>: `a:stock`, `<span class="number">5</span>`, </span><br><span class="line">#发送事务中的第二个操作，这个操作是正确的命令，Redis把该命令入队</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> DECR b:stock</span><br><span class="line">QUEUED</span><br><span class="line">#实际执行事务，但是之前命令有错误，所以Redis拒绝执行</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">EXEC</span></span><br><span class="line">(error) EXECABORT Transaction discarded because <span class="keyword">of</span> previous errors.</span><br></pre></td></tr></table></figure></li>
<li><p><strong>第二种情况：</strong> 事务操作入队时，命令和操作的数据类型不匹配，但 Redis 实例没有检查出错误。但是，在执行完 EXEC 命令以后，Redis 实际执行这些事务操作时，就会报错。不过，需要注意的是，虽然 Redis 会对错误命令报错，但还是会把正确的命令执行完。在这种情况下，<strong>事务的原子性就无法得到保证了。</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#开启事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> MULTI</span><br><span class="line">OK</span><br><span class="line">#发送事务中的第一个操作，LPOP命令操作的数据类型不匹配，此时并不报错</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> LPOP a:stock</span><br><span class="line">QUEUED</span><br><span class="line">#发送事务中的第二个操作</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> DECR b:stock</span><br><span class="line">QUEUED</span><br><span class="line">#实际执行事务，事务第一个操作执行报错</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">EXEC</span></span><br><span class="line"><span class="number">1</span>) (error) WRONGTYPE Operation against a key holding the wrong kind <span class="keyword">of</span> <span class="keyword">value</span></span><br><span class="line"><span class="number">2</span>) (<span class="type">integer</span>) <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>传统数据库（例如 MySQL）在<strong>执行事务时，会提供回滚机制，当事务执行发生错误时，事务中的所有操作都会撤销，已经修改的数据也会被恢复到事务执行前的状态</strong>，那么，在刚才的例子中，如果命令实际执行时报错了，是不是可以用回滚机制恢复原来的数据呢？</p>
<p><strong>Redis 中并没有提供回滚机制。虽然 Redis 提供了 DISCARD 命令，但是，这个命令只能用来主动放弃事务执行，把暂存的命令队列清空，起不到回滚的效果。</strong></p>
<p>DISCARD 命令具体怎么用呢？我们来看下下面的代码。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">#读取a:stock的值<span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">GET</span> a:stock</span><br><span class="line">&quot;4&quot;</span><br><span class="line">#开启事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> MULTI </span><br><span class="line">OK</span><br><span class="line">#发送事务的第一个操作，对a:stock减<span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> DECR a:stock</span><br><span class="line">QUEUED</span><br><span class="line">#执行DISCARD命令，主动放弃事务</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> DISCARD</span><br><span class="line">OK</span><br><span class="line">#再次读取a:stock的值，值没有被修改</span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">6379</span><span class="operator">&gt;</span> <span class="keyword">GET</span> a:stock</span><br><span class="line">&quot;4&quot;</span><br></pre></td></tr></table></figure></li>
<li><p><strong>第三种情况：</strong> <strong>在执行事务的 EXEC 命令时，Redis 实例发生了故障，导致事务执行失败。</strong></p>
<p>在这种情况下，如果 Redis 开启了 AOF 日志，那么，只会有部分的事务操作被记录到 AOF 日志中。我们需要使用 redis-check-aof 工具检查 AOF 日志文件，这个工具可以把未完成的事务操作从 AOF 文件中去除。这样一来，我们使用 AOF 恢复实例后，事务操作不会再被执行，<strong>从而保证了原子性。</strong></p>
<p><strong>当然，如果 AOF 日志并没有开启，那么实例重启后，数据也都没法恢复了，此时，也就谈不上原子性了。</strong></p>
</li>
</ul>
<p><strong>小结</strong></p>
<ul>
<li>命令入队时就报错，会放弃事务执行，保证原子性；</li>
<li>命令入队时没报错，实际执行时报错，不保证原子性；</li>
<li>EXEC 命令执行时实例故障，如果开启了 AOF 日志，可以保证原子性。</li>
</ul>
<h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><ul>
<li><p><strong>情况一：命令入队时就报错</strong></p>
<p>在这种情况下，事务本身就会被放弃执行，所以可以保证数据库的一致性。</p>
</li>
<li><p><strong>情况二：命令入队时没报错，实际执行时报错</strong></p>
<p>在这种情况下，有错误的命令不会被执行，正确的命令可以正常执行，也不会改变数据库的一致性。</p>
</li>
<li><p><strong>情况三：EXEC 命令执行时实例发生故障</strong></p>
<p>在这种情况下，实例故障后会进行重启，这就和数据恢复的方式有关了，我们要根据实例是否开启了 RDB 或 AOF 来分情况讨论下。</p>
<ul>
<li><p>如果我们没有开启 RDB 或 AOF，那么，实例故障重启后，数据都没有了，数据库是一致的。</p>
</li>
<li><p>如果我们使用了 RDB 快照，因为 RDB 快照不会在事务执行时执行，所以，事务命令操作的结果不会被保存到 RDB 快照中，使用 RDB 快照进行恢复时，数据库里的数据也是一致的。</p>
</li>
<li><p>如果我们使用了 AOF 日志，而事务操作还没有被记录到 AOF 日志时，实例就发生了故障，那么，使用 AOF 日志恢复的数据库数据是一致的。如果只有部分操作被记录到了 AOF 日志，我们可以使用 redis-check-aof 清除事务中已经完成的操作，数据库恢复后也是一致的。</p>
</li>
</ul>
<p><strong>小结：</strong> 在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性属性是有保证的。</p>
</li>
</ul>
<h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>事务的隔离性保证，会受到和事务一起执行的并发操作的影响。而事务执行又可以分成命令入队（EXEC 命令执行前）和命令实际执行（EXEC 命令执行后）两个阶段，所以，我们就针对这两个阶段，分成两种情况来分析：</p>
<ol>
<li>并发操作在 EXEC 命令前执行，此时，隔离性的保证要使用 WATCH 机制来实现，否则隔离性无法保证；</li>
<li>并发操作在 EXEC 命令后执行，此时，隔离性可以保证。</li>
</ol>
<p>详细描述：</p>
<ol>
<li><p><strong>一个事务的 EXEC 命令还没有执行时，事务的命令操作是暂存在命令队列中的。</strong>此时，如果有其它的并发操作，我们就需要看事务是否使用了 WATCH 机制。</p>
<p><strong>WATCH 机制的作用是</strong>，在事务执行前，监控一个或多个键的值变化情况，当事务调用 EXEC 命令执行时，WATCH 机制会先检查监控的键是否被其它客户端修改了。如果修改了，就放弃事务执行，避免事务的隔离性被破坏。然后，客户端可以再次执行事务，此时，如果没有并发修改事务数据的操作了，事务就能正常执行，<strong>隔离性也得到了保证。</strong></p>
<img src="https://static001.geekbang.org/resource/image/4f/73/4f8589410f77df16311dd29131676373.jpg" alt="img" style="zoom:18%;" />

<ul>
<li>在 t1 时，客户端 X 向实例发送了 WATCH 命令。实例收到 WATCH 命令后，开始监测 a:stock 的值的变化情况。</li>
<li>紧接着，在 t2 时，客户端 X 把 MULTI 命令和 DECR 命令发送给实例，实例把 DECR 命令暂存入命令队列。</li>
<li>在 t3 时，客户端 Y 也给实例发送了一个 DECR 命令，要修改 a:stock 的值，实例收到命令后就直接执行了。</li>
<li>等到 t4 时，实例收到客户端 X 发送的 EXEC 命令，但是，实例的 WATCH 机制发现 a:stock 已经被修改了，就会放弃事务执行。这样一来，事务的隔离性就可以得到保证了。</li>
</ul>
<p><strong>如果没有使用 WATCH 机制</strong>，在 EXEC 命令前执行的并发操作是会对数据进行读写的。而且，在执行 EXEC 命令的时候，事务要操作的数据已经改变了，在这种情况下，Redis 并没有做到让事务对其它操作隔离，<strong>隔离性也就没有得到保障</strong>。</p>
<p>如果没有使用 WATCH 机制，在 EXEC 命令前执行的并发操作是会对数据进行读写的。而且，在执行 EXEC 命令的时候，事务要操作的数据已经改变了，在这种情况下，Redis 并没有做到让事务对其它操作隔离，隔离性也就没有得到保障。</p>
<img src="https://static001.geekbang.org/resource/image/8c/57/8ca37debfff91282b9c62a25fd7e9a57.jpg" alt="img" style="zoom:18%;" />

<p>在 t2 时刻，客户端 X 发送的 EXEC 命令还没有执行，但是客户端 Y 的 DECR 命令就执行了，此时，a:stock 的值会被修改，这就无法保证 X 发起的事务的隔离性了。</p>
</li>
<li><p><strong>并发操作在 EXEC 命令之后被服务器端接收并执行。</strong></p>
<p>因为 Redis 是用单线程执行命令，而且，EXEC 命令执行后，Redis 会保证先把命令队列中的所有命令执行完。所以，在这种情况下，并发操作不会破坏事务的隔离性，如下图所示：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/11a1eff930920a0b423a6e46c23f44ae.jpg" alt="img" style="zoom:18%;" /></li>
</ol>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>因为 Redis 是内存数据库，所以，数据是否持久化保存完全取决于 Redis 的持久化配置模式。</p>
<ul>
<li><p>如果 Redis 没有使用 RDB 或 AOF，那么事务的持久化属性肯定得不到保证。<strong>如果 Redis 使用了 RDB 模式，那么，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，这种情况下，事务修改的数据也是不能保证持久化的。</strong></p>
</li>
<li><p>如果 Redis 采用了 AOF 模式，因为 AOF 模式的三种配置选项 no、everysec 和 always 都会存在数据丢失的情况，所以，<strong>事务的持久性属性也还是得不到保证。</strong></p>
</li>
</ul>
<p><strong>不管 Redis 采用什么持久化模式，事务的持久性属性是得不到保证的。</strong></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Redis 通过 MULTI、EXEC、DISCARD 和 WATCH 四个命令来支持事务机制。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/9571308df0620214d7ccb2f2cc73a250.jpg" alt="img" style="zoom:20%;" />

<p>Redis 的事务机制<strong>可以保证一致性和隔离性，但是无法保证持久性</strong>。不过，因为 Redis 本身是内存数据库，持久性并不是一个必须的属性，我们更加关注的还是原子性、一致性和隔离性这三个属性。原子性的情况比较复杂，<strong>只有当事务中使用的命令语法有误时，原子性得不到保证，在其它情况下，事务都可以原子性执行。</strong></p>
<p>建议：<strong>严格按照 Redis 的命令规范进行程序开发，并且通过 code review 确保命令的正确性。</strong>这样一来，Redis 的事务机制就能被应用在实践中，保证多操作的正确执行。每课一问</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p><strong>在执行事务时，如果 Redis 实例发生故障，而 Redis 使用了 RDB 机制，那么，事务的原子性还能得到保证吗？</strong></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>二分查找</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h1><p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p>
<span id="more"></span>

<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/8bce81259abf0e9a06f115e22586b829.jpg" alt="img"></p>
<p><strong>时间复杂度：</strong> 我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/d1e4fa1542e187184c87c545c2fe4794.jpg" alt="img"></p>
<p>可以看出来，这是一个等比数列。其中 <code>n/(2^k) = 1</code> 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 <code>n/(2^k) = 1</code>，我们可以求得 <code>k = log2n</code>，所以时间复杂度就是 <code>O(logn)</code>。</p>
<p><strong>注意：</strong> 用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，<code>O(1)</code> 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以， <strong>常量级时间复杂度的算法有时候可能还没有 <code>O(logn)</code> 的算法执行效率高。</strong></p>
<h1 id="递归与非递归实现"><a href="#递归与非递归实现" class="headerlink" title="递归与非递归实现"></a>递归与非递归实现</h1><ul>
<li><p>寻找一个数（基本的二分搜索）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearchInternally</span>(a, mid+<span class="number">1</span>, high, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearchInternally</span>(a, low, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bsearchInternally</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二分查找的变形问题"><a href="#二分查找的变形问题" class="headerlink" title="二分查找的变形问题"></a>二分查找的变形问题</h1><p>有序数据集合中存在重复的数据</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4221d02a2e88e9053085920f13f9ce36.jpg" alt="img"></p>
<h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/503c572dd0f9d734b55f1bd12765c4f8.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || nums[mid - <span class="number">1</span>] != target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 a[mid]等于要查找的值时，我们就需要确认一下这个 a[mid]是不是第一个值等于给定值的元素。</p>
<ul>
<li>如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；</li>
<li>如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素。</li>
<li>如果经过检查之后发现 a[mid]前面的一个元素 a[mid-1]也等于 value，那说明此时的 a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</li>
</ul>
<h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果 a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素。</p>
</li>
<li><p>如果我们经过检查之后，发现 a[mid]后面的一个元素 a[mid+1]也等于 value，那说明当前的这个 a[mid]并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p>
</li>
</ul>
<h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch::firstBiggerSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 a[mid]小于要查找的值 value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新 low=mid+1。</li>
<li>对于 a[mid]大于等于给定值 value 的情况，我们要先看下这个 a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid]前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid]就是我们要找的元素。</li>
<li>如果 a[mid-1]也大于等于要查找的值 value，那说明要查找的元素在[low, mid-1]之间，所以，我们将 high 更新为 mid-1。</li>
</ul>
<h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找最后一个小于等于target的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch::lastLessSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><ul>
<li> <strong>二分查找依赖的是顺序表结构，简单点说就是数组。</strong> </li>
</ul>
<p>  那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p>
<ul>
<li><p> <strong>二分查找针对的是有序数据。</strong></p>
</li>
<li><p>静态数据：没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p>
</li>
<li><p>动态数据：如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p>
</li>
<li><p> <strong>数据量太小不适合二分查找。</strong></p>
</li>
</ul>
<p>  如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p>
<p>  如果数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找。比如很长的字符串比较</p>
<ul>
<li> <strong>数据量太大也不适合二分查找。</strong></li>
</ul>
<p>  二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 <code>1GB</code> 大小的数据，如果希望用数组来存储，那就需要 <code>1GB</code> 的连续内存空间。</p>
<ul>
<li>二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。</li>
</ul>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="链表二分查找复杂度"><a href="#链表二分查找复杂度" class="headerlink" title="链表二分查找复杂度"></a>链表二分查找复杂度</h2><p>如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？</p>
<p>假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):</p>
<p>第一次查找中间点，需要移动指针n/2次；</p>
<p>第二次，需要移动指针n/4次；</p>
<p>第三次需要移动指针n/8次；<br>……<br>以此类推，一直到1次为值</p>
<p>总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.</p>
<p>最后算法时间复杂度是：O(n-1)，忽略常数，记为<code>O(n)</code>，时间复杂度和顺序查找时间复杂度相同</p>
<p>但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p>
<h2 id="如何编程实现“求一个数的平方根”？要求精确到小数点后-6-位。"><a href="#如何编程实现“求一个数的平方根”？要求精确到小数点后-6-位。" class="headerlink" title="如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。"></a>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rootbinarysearch</span><span class="params">(<span class="keyword">double</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> lower = <span class="number">1</span>, upper = num, curValue;</span><br><span class="line">    <span class="keyword">if</span>(lower &gt; upper)</span><br><span class="line">        std::<span class="built_in">swap</span>(lower,upper);</span><br><span class="line">	<span class="keyword">while</span>(upper-lower &gt; <span class="number">0.00000001</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		curValue = lower+(upper-lower)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(curValue*curValue &lt; num)</span><br><span class="line">			lower = curValue;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			upper = curValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> curValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如何在-1000-万个整数中快速查找某个整数？"><a href="#如何在-1000-万个整数中快速查找某个整数？" class="headerlink" title="如何在 1000 万个整数中快速查找某个整数？"></a>如何在 1000 万个整数中快速查找某个整数？</h2><p>假设内存限制是 <code>100MB</code>，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 <code>80MB</code>，符合内存的限制。我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p>
<p><strong>用散列表或二叉树行么？</strong></p>
<p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 1000 万的数据，用 <code>100MB</code> 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p>
<h2 id="如何快速定位IP对应的省份地址？"><a href="#如何快速定位IP对应的省份地址？" class="headerlink" title="如何快速定位IP对应的省份地址？"></a>如何快速定位<code>IP</code>对应的省份地址？</h2><ol>
<li>如果 <code>IP</code> 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 <code>IP</code> 从小到大排序。如何来排序呢？我们知道，<code>IP</code> 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</li>
<li>当我们要查询某个 <code>IP</code> 归属地时，我们可以先通过二分查找，找到最后一个起始 <code>IP</code> 小于等于这个 <code>IP</code> 的 <code>IP</code> 区间</li>
<li>然后，检查这个 <code>IP</code> 是否在这个 <code>IP</code> 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</li>
</ol>
<h2 id="循环有序数组的查找"><a href="#循环有序数组的查找" class="headerlink" title="循环有序数组的查找"></a>循环有序数组的查找</h2><p>如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p>
<p>循环数组性质：以数组中间点为分区，数组分成一个有序数组和一个循环有序数组。</p>
<p>如果首元素 arr[low] &lt; arr[mid]，左半部分：<strong>有序**，右半部分：循环有序；<br>如果首元素 arr[low] &gt; arr[mid]，右半部分：</strong>有序<strong>，左半部分：循环有序；<br>判断查找的数是否在</strong>有序**的半边范围内，更新上下限<br>时间复杂度为 <code>O(logN)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch::circleBinarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123; <span class="comment">// 转折点在右边，左边有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 转折点在左边，右边有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做 <strong>跳表（Skip list）</strong> 。</p>
<h2 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<p><img src="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg" alt="img"></p>
<p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层。图中的 down 表示 down 指针，指向下一级结点。</p>
<p><img src="https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg" alt="img"></p>
<p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点， <strong>现在只需要遍历 7 个结点。</strong></p>
<p><strong>加了一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。那如果我们再加一级索引呢？效率会不会提升更多呢？</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt="img"></p>
<p>现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。</p>
<p><img src="https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="img"></p>
<p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后， <strong>查找效率的提升就会非常明显。</strong></p>
<h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>在一个单链表中查询某个数据的时间复杂度是 O(n)。那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？</p>
<p>按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)。</strong></p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 <code>n/(2^h)=2</code>，从而求得 <code>h=log2n-1</code>。如果包含原始链表这一层，整个跳表的高度就是 <code>log2n</code>。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 <code>O(m*logn)</code>。</p>
<p><strong>那这个 m 的值是多少呢？</strong> 按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，为什么是 3 呢？我来解释一下。</p>
<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>
<p><img src="https://static001.geekbang.org/resource/image/d0/0c/d03bef9a64a0368e6a0d23ace8bd450c.jpg" alt="img"></p>
<p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇？不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引。</p>
<h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<p><img src="https://static001.geekbang.org/resource/image/10/55/100e9d6e5abeaae542cf7841be3f8255.jpg" alt="img"></p>
<p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。那我们有没有办法降低索引占用的内存空间呢？</p>
<p>如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？</p>
<p><img src="https://static001.geekbang.org/resource/image/0b/f7/0b0680ecf500f9349fc142e1a9eb73f7.jpg" alt="img"></p>
<p>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。</p>
<p><img src="https://static001.geekbang.org/resource/image/19/95/192c480664e35591360cee96ff2f8395.jpg" alt="img"></p>
<p>通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p>
<p><strong>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</strong></p>
<h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>实际上，跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 <code>O(logn)</code>。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 <code>O(logn)</code>。</p>
<p><img src="https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="img"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p>
<h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><img src="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="img"></p>
<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p><strong>跳表是通过随机函数来维护前面提到的“平衡性”。</strong></p>
<p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p><img src="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg" alt="img"></p>
<h2 id="为什么-Redis-要用跳表来实现有序集合，而不是红黑树？"><a href="#为什么-Redis-要用跳表来实现有序集合，而不是红黑树？" class="headerlink" title="为什么 Redis 要用跳表来实现有序集合，而不是红黑树？"></a>为什么 <code>Redis</code> 要用跳表来实现有序集合，而不是红黑树？</h2><p><code>Redis</code> 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。</p>
<p><code>Redis</code> 中的有序集合支持的核心操作主要有下面这几个：</p>
<ul>
<li>插入一个数据；</li>
<li>删除一个数据；</li>
<li>查找一个数据；</li>
<li>按照区间查找数据（比如查找值在[100, 356]之间的数据）；</li>
<li>迭代输出有序序列。</li>
</ul>
<p><strong>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</strong></p>
<p><strong>对于按照区间查找数据这个操作，跳表可以做到 <code>O(logn) </code>的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</strong></p>
<p>当然，<code>Redis</code> 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p>
<p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h1><ul>
<li><p>堆是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p>
</li>
<li><p>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>
</li>
</ul>
<p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。</p>
<span id="more"></span>

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4c452a1ad3b2d152daa2727d06097099.jpg" alt="img" style="zoom: 50%;" />

<p>第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。</p>
<h1 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h1><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="img" style="zoom:50%;" />

<p>从图中我们可以看到，数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为i/2 的节点。</p>
<h2 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h2><p><strong>堆化：</strong> 如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做 <strong>堆化</strong> （<code>heapify</code>）。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/e578654f930002a140ebcf72b11eb722.jpg" alt="img" style="zoom:50%;" />

<p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/e3744661e038e4ae570316bc862b2c0e.jpg" alt="img" style="zoom:50%;" />

<h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p>
<p>这种堆化过程不满足完全二叉树。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/5916121b08da6fc0636edf1fc24b5a81.jpg" alt="img" style="zoom:50%;" />

<p>我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是 <strong>从上往下</strong> 的堆化方法。</p>
<p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/110d6f442e718f86d2a1d16095513260.jpg" alt="img" style="zoom:50%;" />

<p><strong>时间复杂度：</strong> 一个包含 n 个节点的完全二叉树，树的高度不会超过<code>logn</code>。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <code>O(logn)</code>。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <code>O(logn)</code>。</p>
<h1 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h1><h2 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1.建堆"></a>1.建堆</h2><p><strong>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。</strong></p>
<ul>
<li> <strong>思路一：</strong> 在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</li>
<li> <strong>思路二：</strong> 第二种实现思路，跟第一种截然相反，也是我这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</li>
</ul>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt="img" style="zoom:50%;" />

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/aabb8d15b1b92d5e040895589c60419d.jpg" alt="img" style="zoom:50%;" />

<p>我们对下标从 <code>n/2</code>开始到 1 的数据进行堆化，下标是<code>n/2 + 1</code>到<code> n</code> 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 <code>n / 2 + 1</code> 到 <code>n</code> 的节点都是叶子节点。</p>
<p><strong>时间复杂度：</strong> 每个节点堆化的时间复杂度是 <code>O(logn)</code>，那 <code>2n+1</code> 个节点堆化的总时间复杂度是不是就是<code> O(nlogn)</code> 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是<code> O(n)</code>。</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。 <strong>只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/899b9f1b40302c9bd5a7f77f042542d5.jpg" alt="img" style="zoom:50%;" />

<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f712f8a7baade44c39edde839cefcc09.jpg" alt="img" style="zoom:50%;" />

<p>把公式左右都乘以 2，就得到另一个公式 <code>S2</code>。我们将 <code>S2</code> 错位对齐，并且用 <code>S2 </code>减去 <code>S1</code>，可以得到 <code>S</code>。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/629328315decd96e349d8cb3940636df.jpg" alt="img" style="zoom:50%;" />

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/46ca25edc69b556b967d2c62388b7436.jpg" alt="img" style="zoom:50%;" />

<p>因为 <code>h=log2n</code>，代入公式 <code>S</code>，就能得到 <code>S=O(n)</code>，所以，建堆的时间复杂度就是 <code>O(n)</code>。</p>
<h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。 <strong>我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</strong> </p>
<p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 <code>n</code> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <code>n−1</code> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <code>n−1</code> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <code>1</code> 的一个元素，排序工作就完成了。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/23958f889ca48dbb8373f521708408d1.jpg" alt="img" style="zoom:50%;" />

<p><strong>空间复杂度：</strong> 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。</p>
<p><strong>时间复杂度：</strong> 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 <code>O(n)</code>，排序过程的时间复杂度是 <code>O(nlogn)</code>，所以，堆排序整体的时间复杂度是 <code>O(nlogn)</code>。</p>
<p><strong>稳定性：</strong> 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
<h1 id="为什么快排要比堆排序好？"><a href="#为什么快排要比堆排序好？" class="headerlink" title="为什么快排要比堆排序好？"></a>为什么快排要比堆排序好？</h1><ul>
<li><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/838a38286dcace89ca63895b77ae8ece.jpg" alt="img" style="zoom:50%;" /></li>
<li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。 <strong>快速排序数据交换的次数不会比逆序度多。</strong> </p>
<p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/6e81fdde42ec3fd288d32eb866867fbd.jpg" alt="img" style="zoom:50%;" /></li>
</ul>
<h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><p>队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<p>一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
<h3 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1. 合并有序小文件"></a>1. 合并有序小文件</h3><p>假设我们有 100 个小文件，每个文件的大小是 <code>100MB</code>，每个文件中存储的都是 <strong>有序</strong> 的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p>
<p>整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p>
<p>假设，这个最小的字符串来自于 <code>13.txt</code> 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p>
<p>这里我们用 <strong>数组</strong> 这种数据结构，来存储从小文件中取出来的字符串。 <strong>每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</strong> 有没有更加高效方法呢？</p>
<p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 <code>O(logn)</code>，<code>n</code> 表示堆中的数据个数，这里就是 100。比原来数组存储的方式要高效很多。</p>
<h3 id="2-高性能定时器"><a href="#2-高性能定时器" class="headerlink" title="2.高性能定时器"></a>2.高性能定时器</h3><p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b04656d27fd0ba112a38a28c892069e7.jpg" alt="img"></p>
<p><strong>轮询的缺点：</strong> 这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p>
<ol>
<li>我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</li>
<li>定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。</li>
<li>这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。</li>
<li>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</li>
<li>定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</li>
</ol>
<h2 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h2><p>我把这种求 Top K 的问题抽象成两类。</p>
<ul>
<li><p>一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。</p>
</li>
<li><p>另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p>
</li>
</ul>
<ol>
<li><p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p>
<p>遍历数组需要 <code>O(n)</code> 的时间复杂度，一次堆化操作需要<code> O(logK)</code> 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 <code>O(nlogK)</code>。</p>
</li>
<li><p>一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。</p>
<p>如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 <code>O(nlogK)</code>，n 表示当前的数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。</p>
</li>
</ol>
<h3 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h3><p>如何求动态数据集合中的中位数。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/1809157fdd804dd40a6a795ec30acbb6.jpg" alt="img" style="zoom:50%;" />

<p>对于一组静态数据，中位数是固定的，我们可以先排序，第 n/2 个数据就是中位数。每次询问中位数的时候，我们直接返回这个固定的值就好了。所以，尽管排序的代价比较大，但是边际成本会很小。但是，如果我们面对的是 <strong>动态数据集合</strong> ，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。</p>
<p><strong>做法：</strong> 维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/08c29d3e014a4baf5f8148c2271e6099.jpg" alt="img" style="zoom:50%;" />

<p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p>
<p>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：如果 n 是偶数，两个堆中的数据个数都是 <code>n/2</code>；如果 <code>n</code> 是奇数，大顶堆有<code> n/2+1</code> 个数据，小顶堆有 <code>n/2</code> 个数据。这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p>
<p>实现在动态数据集合中求中位数的操作。插入数据因为需要涉及堆化，所以 <strong>时间复杂度</strong> 变成了 <code>O(logn)</code>，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以 <strong>时间复杂度</strong> 就是 O(1)。</p>
<p><strong>实际上可以利用堆来求任意比例的top，比如求前60%大的数据，方法与上面类似，只是维护大顶堆和小顶堆的相对大小变了。</strong></p>
<h1 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h1><ul>
<li><p>对于完全二叉树来说，下标从 <code>2n+1 到 n</code> 的都是叶子节点，这个结论是怎么推导出来的呢？</p>
<p>堆是完全二叉树，求最后的非叶子节点即是求最大的叶子节点的父节点。最大的叶子节点下标为<code>n</code>，他的父节点为<code>n/2</code>，这是最后一个非叶子节点，所以<code>n/2+1到n</code>都是叶子节点。</p>
</li>
<li><p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？假设内存为<code>1G</code>。</p>
<p>因为用户搜索的关键词，有很多可能都是重复的，所以我们首先要统计每个搜索关键词出现的频率。我们可以通过散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构，来记录关键词及其出现的次数。</p>
<ol>
<li>假设我们选用散列表。我们就顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，我们去散列表中查询。如果存在，我们就将对应的次数加一；如果不存在，我们就将它插入到散列表，并记录次数为 1。以此类推，等遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</li>
<li>然后，我们再根据前面讲的用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。</li>
</ol>
<p><strong>漏洞：</strong> 10 亿的关键词还是很多的。我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 <code>5GB</code> 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而我们的机器只有 <code>1GB</code> 的可用内存空间，所以我们无法一次性将所有的搜索关键词加入到内存中。这个时候该怎么办呢？</p>
<p><strong>解决：</strong> 相同数据经过哈希算法得到的哈希值是一样的。</p>
<ol>
<li>我们可以根据哈希算法的这个特点，将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。我们创建 10 个空文件 00，01，02，……，09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。</li>
<li>对这 10 亿个关键词分片之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 <code>500MB</code>。<code>1GB</code> 的内存完全可以放得下。</li>
<li>我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>散列表</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列表（上）"><a href="#散列表（上）" class="headerlink" title="散列表（上）"></a>散列表（上）</h2><h3 id="1-散列思想："><a href="#1-散列思想：" class="headerlink" title="1.散列思想："></a>1.散列思想：</h3><p><strong>散列表(Hash Table)用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p>
<span id="more"></span>

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/92c89a57e21f49d2f14f4424343a2773.jpg" alt="img" style="zoom: 50%;" />

<ul>
<li>特性：<ul>
<li>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 <code>O(1)</code> 的特性。</li>
<li>我们通过 <strong>散列函数把元素的键值映射为下标，即hash(key)</strong> ，然后将数据存储在数组中对应下标的位置。</li>
<li>当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</li>
</ul>
</li>
</ul>
<h3 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2.散列函数"></a>2.散列函数</h3><p>顾名思义，它是一个函数。我们可以把它定义成  <strong>hash(key)</strong> ，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p>
<p>举个例子：假如我们有 89 名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这 89 名选手的编号依次是 1 到 89。现在我们希望编程实现这样一个功能，通过编号快速找到对应的选手信息。你会怎么做呢？</p>
<p>我们可以把这 89 名选手的信息（年纪，班级，编号）放在数组里。编号为 1 的选手，我们放到数组中下标为 1 的位置；编号为 2 的选手，我们放到数组中下标为 2 的位置。以此类推，编号为 k 的选手放到数组中下标为 k 的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取后两位字符</span></span><br><span class="line">  string lastTwoChars = key.<span class="built_in">substr</span>(length<span class="number">-2</span>, length);</span><br><span class="line">  <span class="comment">// 将后两位字符转换为整数</span></span><br><span class="line">  <span class="keyword">int</span> hashValue = convert lastTwoChas to <span class="keyword">int</span>-type;</span><br><span class="line">  <span class="keyword">return</span> hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>散列函数设计的 <strong>基本要求：</strong><ul>
<li>散列函数计算得到的散列值是一个非负整数；（数组下标从0开始）</li>
<li>如果 <code>key1 = key2</code>，那 <code>hash(key1) == hash(key2)；</code></li>
<li>如果 <code>key1 ≠ key2</code>，那 <code>hash(key1) ≠ hash(key2)。</code><strong>但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的，这就是散列冲突。</strong></li>
</ul>
</li>
</ul>
<h3 id="3-散列冲突"><a href="#3-散列冲突" class="headerlink" title="3.散列冲突"></a>3.散列冲突</h3><h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a><strong>1.开放寻址法</strong></h4><p><strong>思想：</strong> 如果出现了散列冲突，我们就重新 <strong>探测</strong> 一个空闲位置，将其插入。探测方法有线性探测，</p>
<ul>
<li><p><strong>线性探测（Linear Probing）</strong> </p>
</li>
<li><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313091944.jpeg" alt="img" style="zoom: 50%;" />

<ul>
<li><p><strong>插入：</strong> 散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
</li>
<li><p><strong>查找：</strong> 我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
</li>
<li><p><strong>删除：</strong> 将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt="img" style="zoom:50%;" />

<blockquote>
<p><strong>我们不能单纯地把要删除的元素设置为空。</strong> 这是为什么呢？</p>
<p>在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p>
</blockquote>
</li>
<li><p><strong>缺点：</strong> 当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
</li>
</ul>
</li>
<li><p><strong>二次探测：</strong> 跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 <code>hash(key)+0，hash(key)+1，hash(key)+2……</code>而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 <code>hash(key)+0，hash(key)+1^2，hash(key)+2^2……</code></p>
</li>
<li><p><strong>双重散列：</strong> 意思就是不仅要使用一个散列函数。我们使用一组散列函数 <code>hash1(key)，hash2(key)，hash3(key)……</code>我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
</li>
<li><p><strong>装载因子：</strong> 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用 <strong>装载因子（load factor）</strong> 来表示空位的多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">散列表的装载因子=填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="img" style="zoom:50%;" />

<ul>
<li><strong>插入：</strong> 通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 <code>O(1)</code>。</li>
<li><strong>查找，删除：</strong> 当查找、删除一个元素时，通过散列函数计算出对应的槽，然后遍历链表查找或者删除。这两个操作的 <strong>时间复杂度</strong> 跟链表的长度<code> k</code> 成正比，也就是 <code>O(k)</code>。对于散列比较均匀的散列函数来说，理论上讲，<code>k=n/m</code>，其中 <code>n</code> 表示<strong>散列中数据的个数</strong>，<code>m</code> 表示散列表中<strong>“槽”的个数</strong>。</li>
</ul>
<h3 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h3><ul>
<li><p>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</p>
<ul>
<li>遍历 10 万条数据，以 <code>URL</code> 为 <code>key</code>，访问次数为 <code>value</code>，存入散列表，同时记录下访问次数的最大值 <code>K</code>，时间复杂度 <code>O(N)</code>。如果 <code>K</code> 不是很大，可以使用桶排序，时间复杂度 <code>O(N)</code>。如果 <code>K</code> 非常大（比如大于 10 万），就使用快速排序，复杂度 <code>O(NlogN)</code>。</li>
</ul>
</li>
<li><p>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p>
<ul>
<li>以第一个字符串数组构建散列表，<code>key </code>为字符串，<code>value</code> 为出现次数。再遍历第二个字符串数组，以字符串为 <code>key</code> 在散列表中查找，如果 <code>value</code> 大于零，说明存在相同字符串。时间复杂度 <code>O(N)</code>。</li>
</ul>
</li>
<li><p>Word 文档中单词拼写检查功能是如何实现的？</p>
<ul>
<li>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 <code>2MB</code> 的存储空间，就算放大 10 倍也就是 <code>20MB</code>。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</li>
</ul>
</li>
</ul>
<h2 id="散列表（中）"><a href="#散列表（中）" class="headerlink" title="散列表（中）"></a>散列表（中）</h2><h3 id="工业级的散列表应该具有哪些特性？"><a href="#工业级的散列表应该具有哪些特性？" class="headerlink" title="工业级的散列表应该具有哪些特性？"></a><strong>工业级的散列表应该具有哪些特性？</strong></h3><ul>
<li><strong>支持快速地查询、插入、删除操作；</strong></li>
<li><strong>内存占用合理，不能浪费过多的内存空间；</strong></li>
<li><strong>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</strong></li>
</ul>
<h3 id="1-如何设计散列函数？"><a href="#1-如何设计散列函数？" class="headerlink" title="1.如何设计散列函数？"></a>1.如何设计散列函数？</h3><ul>
<li>散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。</li>
<li>散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。<strong>散列表会退化为链表</strong></li>
</ul>
<h3 id="2-装载因子过大了怎么办？"><a href="#2-装载因子过大了怎么办？" class="headerlink" title="2.装载因子过大了怎么办？"></a>2.装载因子过大了怎么办？</h3><p><strong>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。</strong>不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<ul>
<li><p><strong>静态数据集合：</strong> 没有频繁插入和删除，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p>
</li>
<li><p><strong>动态数据集合：</strong> 数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，我们该如何处理呢？</p>
<ul>
<li><p><strong>动态扩容：</strong> 当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。针对数组的扩容，数据搬移操作比较简单。但是，<strong>针对散列表的扩容，数据搬移操作要复杂很多。</strong>因为散列表的大小变了，<strong>数据的存储位置也变了</strong>，所以我们需要通过散列函数重新计算每个数据的存储位置。</p>
</li>
<li><p><strong>插入：</strong> 插入一个数据，最好情况下，不需要扩容，**最好时间复杂度是 O(1)<strong>。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，</strong>所以时间复杂度是 O(n)**。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
</li>
<li><p><strong>删除：</strong> 随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-如何避免低效的扩容？"><a href="#3-如何避免低效的扩容？" class="headerlink" title="3.如何避免低效的扩容？"></a>3.如何避免低效的扩容？</h3><p>为了解决一次性扩容耗时过多的情况，我们可以将<strong>扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</strong></p>
<ul>
<li><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt="img" style="zoom:50%;" /></li>
</ul>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 **O(1)**。</p>
<h3 id="4-如何选择冲突解决方法？"><a href="#4-如何选择冲突解决方法？" class="headerlink" title="4.如何选择冲突解决方法？"></a>4.如何选择冲突解决方法？</h3><ul>
<li><p><strong>开放寻址法：</strong> </p>
<ul>
<li><strong>优点：</strong> 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单</li>
<li><strong>缺点：</strong> 用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</li>
<li><strong>适用场景：</strong> <strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong></li>
</ul>
</li>
<li><p><strong>链表法：</strong> </p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</li>
<li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li>
</ul>
</li>
<li><p><strong>缺点：</strong> 链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p>
</li>
<li><p><strong>改造：</strong> 实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是<code> O(logn)</code>。这样也就有效避免了前面讲到的散列碰撞攻击。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313100019.jpeg" alt="img"></p>
</li>
<li><p><strong>适用场景：</strong> <strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="散列表（下）"><a href="#散列表（下）" class="headerlink" title="散列表（下）"></a>散列表（下）</h2><h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p>我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的<strong>尾部</strong>删除。</p>
<p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的<strong>头部</strong>；如果找到了，我们就把它移动到链表的<strong>头部</strong>。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 **O(n)**。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330104857654.png" alt="image-20210330104857654"></p>
<p>一个缓存（cache）系统主要包含下面这几个操作：</p>
<ul>
<li><strong>往缓存中添加一个数据；</strong><ul>
<li>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的头部。</li>
</ul>
</li>
<li><strong>从缓存中删除一个数据；</strong><ul>
<li>我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</li>
</ul>
</li>
<li><strong>在缓存中查找一个数据。</strong><ul>
<li>添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的头部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的尾部删除，然后再将数据放到链表的头部；如果没有满，就直接将数据放到链表的头部。</li>
</ul>
</li>
</ul>
<p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313143709.jpeg" alt="img" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>() : <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value) : <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> capacity, size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查找key在不在cache中，如果在就移到头部</span></span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) == cache.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 获取值并put</span></span><br><span class="line">        <span class="keyword">int</span> val = cache[key]-&gt;value;</span><br><span class="line">        <span class="built_in">put</span>(key, val);</span><br><span class="line">        <span class="keyword">return</span> val;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) != cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            DLinkedNode* tmp = cache[key];</span><br><span class="line">            <span class="comment">// 更新数据</span></span><br><span class="line">            tmp-&gt;value = value;</span><br><span class="line">            <span class="comment">// 移到头部</span></span><br><span class="line">            <span class="built_in">moveToHead</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新建节点，并插入</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="built_in">addFirst</span>(node);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="comment">// 判断缓存容量是否达到上限</span></span><br><span class="line">            <span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line">                DLinkedNode* last = <span class="built_in">removeLast</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">                --size;</span><br><span class="line">                <span class="keyword">delete</span> last;</span><br><span class="line">                last = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向头部添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除x节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        <span class="comment">// delete node;</span></span><br><span class="line">        <span class="comment">// node = nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点移至头部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">addFirst</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* tmp = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">remove</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>排序</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h1><h2 id="1-排序算法的执行效率"><a href="#1-排序算法的执行效率" class="headerlink" title="1. 排序算法的执行效率"></a>1. 排序算法的执行效率</h2><ul>
<li> <strong>最好情况、最坏情况、平均情况时间复杂度</strong> </li>
<li>分别给出排序算法 <strong>三种情况</strong> 的时间复杂度</li>
<li>同时给出三种情况时间复杂度对应的 <strong>原始数据</strong> 是什么样的？</li>
<li> <strong>时间复杂度的系数、常数 、低阶</strong></li>
<li>时间复杂度反映的是数据规模 n **很大 **的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。</li>
<li>实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模 <strong>很小</strong> 的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</li>
<li> <strong>比较次数和交换（或移动）次数</strong> ：基于 <strong>比较</strong> 的排序算法执行过程中，会涉及两种操作。</li>
<li> <strong>元素比较大小</strong> </li>
<li> <strong>元素交换或移动</strong> </li>
</ul>
<span id="more"></span>

<h2 id="2-排序算法的内存消耗"><a href="#2-排序算法的内存消耗" class="headerlink" title="2. 排序算法的内存消耗"></a>2. 排序算法的内存消耗</h2><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<h2 id="3-排序算法的稳定性"><a href="#3-排序算法的稳定性" class="headerlink" title="3. 排序算法的稳定性"></a>3. 排序算法的稳定性</h2><ul>
<li><p> <strong>概念</strong> ：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
</li>
<li><p> <strong>为什么要考察算法的稳定性？</strong></p>
</li>
<li><p>真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。</p>
</li>
<li><blockquote>
<p>举例：我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p>
<ul>
<li>解法一：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</li>
<li>解法二：我们先按照下单时间给订单排序，注意是按照 <strong>下单时间</strong> ，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</li>
<li> <strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong> 第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><ul>
<li><p> <strong>思想</strong> ：冒泡操作 <strong>只会操作相邻的两个数据</strong> 。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系，如果不满足就让它俩交换。 <strong>一次冒泡操作会至少让一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。</strong> </p>
</li>
<li><p> <strong>优化：</strong> 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p>
</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E5%86%92%E6%B3%A1%E4%BC%98%E5%8C%96.jpg"></p>
<ul>
<li> <strong>代码</strong> </li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::BubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;			</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;   <span class="comment">// j+1&lt;n-i, 每次冒泡之后都有一个元素被排序到正确位置（末尾）</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;			<span class="comment">// 注意：没有等号，保证了稳定性</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>)      <span class="comment">// 没有数据交换提前退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>性能分析：</strong> </li>
<li>冒泡排序是 <strong>原地排序算法</strong> 。冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</li>
<li>冒泡排序是 <strong>稳定的算法</strong> 。在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性， <strong>当有相邻的两个元素大小相等的时候，我们不做交换</strong> ，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</li>
<li>时间复杂度：<ul>
<li> <strong>最好情况时间复杂度：</strong> 排序数据已经 <strong>有序</strong> 。我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是   <strong>O(n)</strong> 。</li>
<li> <strong>最坏情况时间复杂度：</strong> 排序数据 <strong>完全倒序</strong> 。我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 <strong>O(n^2)</strong> 。</li>
<li> <strong>平均情况时间复杂度：</strong> <strong>O(n^2)</strong> 。</li>
</ul>
</li>
</ul>
<h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h1><ul>
<li><p> <strong>思想：</strong> 一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p>
</li>
<li><p> <strong>操作：</strong> 我们将数组中的数据分为两个区间， <strong>已排序区间</strong> 和 <strong>未排序区间</strong> 。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是 <strong>取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</strong> 重复这个过程，直到未排序区间中元素为空，算法结束。</p>
</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg"></p>
<ul>
<li> <strong>代码1：</strong> </li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::InsertionSort1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;      <span class="comment">// j-1&gt;=0, i+1&lt;n</span></span><br><span class="line">            <span class="comment">// 注意没有=，即当等于是什么都不做，此时新插入的元素在与其相等的元素之后，保证了相同元素前后顺序不变</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>代码2：</strong> 相比第一种赋值操作只需要一步，下面更优。</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::InsertionSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];     <span class="comment">// 要插入的值</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; j&gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; value)</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p> <strong>性能分析：</strong> </p>
</li>
<li><p>插入排序是 <strong>原地排序算法</strong> 。</p>
</li>
<li><p>插入排序是 <strong>稳定的排序算法</strong> 。对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
</li>
<li><p> <strong>时间复杂度</strong> ：    +  <strong>最好情况时间复杂度：</strong> 如果要排序的数据已经是 <strong>有序</strong> 的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为  <strong>O(n)</strong> 。注意，这里是 <strong>从尾到头遍历已经有序的数据</strong> 。    + <strong>最坏情况时间复杂度：</strong> 如果数组是 <strong>倒序</strong> 的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 <strong>O(n^2)</strong> 。    + <strong>平均情况时间复杂度：</strong>  <strong>数组中插入一个数据的平均时间复杂度是 O(n)。</strong> 所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 <strong>O(n^2)</strong> 。</p>
</li>
</ul>
<h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><ul>
<li> <strong>思想：</strong> 选择排序每次会从未排序区间中 <strong>找到最小的元素</strong> ，将其放到已排序区间的 <strong>末尾</strong> 。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg"></p>
<ul>
<li> <strong>代码：</strong> </li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::SelectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> min_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当j == i时说明它就在正确的位置，不需要交换，不然会多一次操作。</span></span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = min;</span><br><span class="line">            arr[min_index] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>算法性能分析：</strong> </p>
<p> <strong>性能分析：</strong> </p>
</li>
<li><p>选择排序是 <strong>原地排序算法</strong> 。</p>
</li>
<li><p>选择排序是 <strong>稳定的排序算法</strong> 。对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
</li>
<li><p> <strong>时间复杂度</strong> ：    +  <strong>最好情况时间复杂度：</strong> 如果要排序的数据已经是 <strong>有序</strong> 的，我们并不需要搬移任何数据。但是每一次操作都需要找到最小值，且不需要交换，时间复杂度为O(n)，总共需要n次操作，所以最好时间复杂度为  <strong>O(n^2)</strong> 。    + <strong>最坏情况时间复杂度：</strong> 如果数组是 <strong>倒序</strong> 的，每次操作需要找到最小值，且需要交换，时间复杂度为O(n)，所以最坏情况时间复杂度为 <strong>O(n^2)</strong> 。    + <strong>平均情况时间复杂度：</strong> <strong>O(n^2)</strong> 。</p>
</li>
</ul>
<blockquote>
<p> <strong>插入排序和冒泡排序的时间复杂度都是O(n^2)，为什么在实际中插入排序比冒泡排序更受欢迎呢？</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">	<span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   	a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   	a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   	flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  	a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p>
</blockquote>
<h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><ul>
<li><p><strong>分治思想：</strong> 如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 <strong>分治算法一般都是用递归来实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。</strong> </p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg"></p>
</li>
<li><p> <strong>分析：</strong> </p>
</li>
<li><p> <strong>递推公式：</strong> </p>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class="number">1</span>…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure>

merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。
</code></pre>
<ul>
<li> <strong>整体框架：</strong> </li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 归并排序算法, A是数组，n表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  // 取p到r之间的中间位置q</span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  // 将A[p...q]和A[q+<span class="number">1.</span>..r]合并为A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

merge(A[p...r], A[p...q], A[q+1...r]) 这个函数的作用就是，将已经有序的 A[p...q]和 A[q+1....r]合并成一个有序的数组，并且放入 A[p....r]。
</code></pre>
<ul>
<li> <strong>merge:</strong> 申请一个临时数组 temp，大小与 A[p…r]相同。我们用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 temp，并且 i 后移一位，否则将 A[j]放入到数组 temp，j 后移一位。</li>
</ul>
<pre><code>![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/merge.jpg)
</code></pre>
<ul>
<li> <strong>代码：</strong> </li>
</ul>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::MergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">MergeSortC</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::MergeSortC</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSortC</span>(arr, lo, mid);</span><br><span class="line">    <span class="built_in">MergeSortC</span>(arr, mid + <span class="number">1</span>, hi);		<span class="comment">// 注意要加1</span></span><br><span class="line">    <span class="built_in">merge</span>(arr, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = hi - lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;              <span class="comment">// index为temp的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;    <span class="comment">// i，j代表两个子数组的下标，注意不是从0开始</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</span><br><span class="line">        <span class="comment">// 如果arr[i]比arr[j]小，则把它arr[i]放进去</span></span><br><span class="line">        temp[index++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];	<span class="comment">// 注意：这里写等于，保证了稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) &#123;</span><br><span class="line">        temp[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        arr[lo++] = temp[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p><strong>性能分析：</strong> </p>
<ul>
<li><p>归并排序是 <strong>稳定的排序算法</strong> 。在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素， <strong>先把 A[p…q]中的元素放入 temp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变</strong> 。所以，归并排序是一个稳定的排序算法。</p>
</li>
<li><p><strong>时间复杂度</strong> ：</p>
<ul>
<li> <strong>递推公式：</strong> </li>
</ul>
  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">T(<span class="number">1</span>) = C；   n=<span class="number">1</span>时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n； n&gt;<span class="number">1</span>	// T(n)代表对n的元素进行排序的时间，则分解成两个子数组排序的时间是T(n/<span class="number">2</span>)。</span><br><span class="line">	 = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>) + n/<span class="number">2</span>) + n = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n </span><br><span class="line">	 = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n </span><br><span class="line">	 = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n ...... </span><br><span class="line">	 = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">当n/<span class="number">2</span>^k=<span class="number">1</span>时，k=log2n, 则T(n) = cn + nlog2n;</span><br></pre></td></tr></table></figure>

<p>  从推导过程来看，归并排序的时间复杂度与有序度无关，所以不管是最好情况、最坏情况，还是平均情况，时间复杂度都是  <strong>O(nlogn)</strong> 。</p>
</li>
<li><p> <strong>空间复杂度：</strong> </p>
</li>
</ul>
<p>  按照正常分析逻辑，空间复杂度分析与时间复杂度递推公式一样，也是O(nlogn)。递归代码的空间复杂度并不能像时间复杂度那样累加。 <strong>尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。</strong> 在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是  <strong>O(n)</strong> 。</p>
</li>
</ul>
<h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h1><ul>
<li> <strong>思想：</strong> 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分， <strong>前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的</strong> 。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E5%BF%AB%E6%8E%921.jpg"></p>
<ul>
<li><p> <strong>分析：</strong> </p>
</li>
<li><p> <strong>递推公式：</strong> </p>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-<span class="number">1</span>) + quick_sort(q+<span class="number">1</span>… r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> <strong>整体框架：</strong> </li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-<span class="number">1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> <strong>partition：</strong> </li>
</ul>
<pre><code>+ 不考虑空间复杂度，可以类似归并的merge。申请两个临时数组 X 和 Y，遍历 A[p...r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p....r]。

  ![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/partition1.jpg)

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::partition3</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[hi - lo + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tempLindex = <span class="number">0</span>, tempRindex = hi - lo;       <span class="comment">// 临时数组的首末位下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) temp[tempLindex++] = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (pivot &lt; arr[i]) temp[tempRindex--] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pivot可能是多个相同的值</span></span><br><span class="line">    <span class="keyword">while</span> (tempLindex &lt;= tempRindex) &#123;</span><br><span class="line">        temp[tempLindex++] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        arr[i] = temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

+ 空间复杂度O(1)

  （1）通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它 **已处理区间** ，A[i...r-1]是 **未处理区间** 。我们每次都从未处理的区间 A[i...r-1]中取一个元素 **A[j]** ，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。

  （2）数组的插入操作如果考虑顺序，则时间复杂度为O(n)，如果不考虑顺序，则可以实现时间复杂度为O(1)， **即在数组末尾插入一个元素，并与插入位置的元素交换**。

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sort::partition2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[hi];</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[hi]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  ![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/partition2.jpg)

+  使用双指针，分别指向数组的首尾，当指针 i 和 j 相遇时主循环退出。在循环中，a[i] 小于pivot时
  我们增大 i ，a[j] 大于pivot时我们减小 j，然后交换a[i] 和a[j] 来保证 i 左侧的元素都不大于 v，j 右侧
  的元素都不小于v。当指针相遇时交换a[lo] 和a[j]，切分结束。

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sort::partition1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;             <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];                <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束，并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; pivot) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; pivot) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[lo], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  ![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/partition3.png)
</code></pre>
<ul>
<li><p><strong>代码：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// version 1 : 空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">QuickSortC</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSortC</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in">partition2</span>(arr, lo, hi);	<span class="comment">// 可用partition2</span></span><br><span class="line">    <span class="built_in">QuickSortC</span>(arr, lo, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSortC</span>(arr, j + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sort::partition1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;             <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];                <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束，并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; pivot) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; pivot) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[lo], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// version 2 : 空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">QuickSortC2</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> parr[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::partition3</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[hi - lo + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> lessPNum = <span class="number">0</span>, largePNum = <span class="number">0</span>;				<span class="comment">// 记录下比哨兵小的和大的个数。</span></span><br><span class="line">    <span class="keyword">int</span> tempLindex = <span class="number">0</span>, tempRindex = hi - lo;       <span class="comment">// 临时数组的首末位下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i])  &#123;</span><br><span class="line">            temp[tempLindex++] = arr[i];</span><br><span class="line">            lessPNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivot &lt; arr[i]) &#123;</span><br><span class="line">            temp[tempRindex--] = arr[i];</span><br><span class="line">            largePNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pivot可能是多个相同的值</span></span><br><span class="line">    <span class="keyword">while</span> (tempLindex &lt;= tempRindex) &#123;</span><br><span class="line">        temp[tempLindex++] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        arr[i] = temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">    parr[<span class="number">0</span>] = lessPNum;</span><br><span class="line">    parr[<span class="number">1</span>] = largePNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSortC2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hi - lo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[lo] &gt; arr[hi]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[lo], arr[hi]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">partition3</span>(arr, lo, hi);                   <span class="comment">// 数据分段&#123;&#123;小于哨兵的&#125;， &#123;等于哨兵的&#125;， &#123;大于哨兵的&#125;&#125;</span></span><br><span class="line">        <span class="keyword">int</span> pl_index = lo + parr[<span class="number">0</span>];               <span class="comment">// 首位哨兵的下标</span></span><br><span class="line">        <span class="keyword">int</span> pr_index = hi - parr[<span class="number">1</span>];               <span class="comment">// 末位哨兵的下标</span></span><br><span class="line">        <span class="keyword">if</span> (pl_index == hi &amp;&amp; pl_index != lo)      <span class="comment">// 哨兵位于最右侧，只有左侧需要排序</span></span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, lo, pl_index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl_index == lo &amp;&amp; pr_index != hi) <span class="comment">// 哨兵位于最左侧，只有右侧需要排序</span></span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, pl_index + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl_index == lo &amp;&amp; pr_index == hi) <span class="comment">// 全是哨兵，直接返回，不需要排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                     <span class="comment">// 分别对[lo...pl_index-1]，[pr_index+1...hi]排序。</span></span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, lo, pl_index - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, pr_index + <span class="number">1</span>, hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>性能分析：</strong> <ul>
<li>快速排序 是<strong>不稳定的排序算法</strong> 。因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</li>
<li><strong>时间复杂度</strong> ：<ul>
<li>快排的时间复杂度与归并排序的时间复杂度分析一样， <strong>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排时间复杂度与归并排序递推求解公式一样，为<code>O(nlogn)</code></strong> 。 <u><strong>公式成立的前提是：每次分区操作选择的pivot合适，正好能将大区间对等地一分为二，但实际上是很难实现的。</strong></u> </li>
<li>如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下， <strong>快排的时间复杂度就从 <code>O(nlogn)</code> 退化成了 O(n^2)</strong> 。</li>
</ul>
</li>
<li> <strong>空间复杂度：</strong> <strong>O(1)</strong> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p> <strong>如何使用快速排序查找数组中第K大元素？</strong> </p>
</li>
<li><p> <strong>思想：</strong> 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。每次partition之后，分区元素就被放置到正确的位置，如果pivot位于倒数第K个位置即n - K，那么就可以返回。如果 p=n-K，那 A[p]就是要求解的元素；如果 n-K&gt;p, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 n-K&lt;p，说明第K大元素出现在A[0,p-1]区间。</p>
</li>
<li><p> <strong>时间的复杂度：</strong> 第一次分区查找需要对大小为n的数组执行分区操作，需要遍历n个元素，第二次分区操作只需要对大小为n/2的数组进行分区操作，…，n+n/2+n/4+n/8+…+1 = 2n - 1。因此复杂度为O(n)。</p>
</li>
<li><p><strong>为了尽量保证分区函数的随机性，每次随机取一个元素放到最后作为pivot。</strong></p>
</li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (k == index) <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; index) <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, index + <span class="number">1</span>, hi, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, lo, index - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (hi - lo + <span class="number">1</span>) + lo;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[hi]);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[hi];</span><br><span class="line">        i = lo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[hi]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h1><h2 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1.建堆"></a>1.建堆</h2><p><strong>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。</strong></p>
<ul>
<li> <strong>思路一：</strong> 在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</li>
<li> <strong>思路二：</strong> 第二种实现思路，跟第一种截然相反。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。 <strong>而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</strong></li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/aabb8d15b1b92d5e040895589c60419d.jpg" alt="img"></p>
<p><strong>我们对下标从 <code>n/2</code>开始到 1 的数据进行堆化，下标是<code>n/2 + 1</code>到<code> n</code> 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 <code>n / 2 + 1</code> 到 <code>n</code> 的节点都是叶子节点。</strong></p>
<p><strong>时间复杂度：</strong> 每个节点堆化的时间复杂度是 <code>O(logn)</code>，那 <code>2n+1</code> 个节点堆化的总时间复杂度是不是就是<code> O(nlogn)</code> 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是<code> O(n)</code>。</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。 <strong>只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</strong></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/899b9f1b40302c9bd5a7f77f042542d5.jpg" alt="img"></p>
<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f712f8a7baade44c39edde839cefcc09.jpg" alt="img"></p>
<p>把公式左右都乘以 2，就得到另一个公式 <code>S2</code>。我们将 <code>S2</code> 错位对齐，并且用 <code>S2 </code>减去 <code>S1</code>，可以得到 <code>S</code>。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/629328315decd96e349d8cb3940636df.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/46ca25edc69b556b967d2c62388b7436.jpg" alt="img"></p>
<p>因为 <code>h=log2n</code>，代入公式 <code>S</code>，就能得到 <code>S=O(n)</code>，所以，建堆的时间复杂度就是 <code>O(n)</code>。</p>
<h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。 <strong>我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</strong> </p>
<p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 <code>n</code> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <code>n−1</code> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <code>n−1</code> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <code>1</code> 的一个元素，排序工作就完成了。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/23958f889ca48dbb8373f521708408d1.jpg" alt="img"></p>
<p><strong>空间复杂度：</strong> 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。</p>
<p><strong>时间复杂度：</strong> 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 <code>O(n)</code>，排序过程的时间复杂度是 <code>O(nlogn)</code>，所以，堆排序整体的时间复杂度是 <code>O(nlogn)</code>。</p>
<p><strong>稳定性：</strong> 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::buildHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> i, <span class="keyword">int</span> dSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = i;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; dSize &amp;&amp; arr[i] &lt; arr[left])</span><br><span class="line">            maxPos = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; dSize &amp;&amp; arr[maxPos] &lt; arr[right])</span><br><span class="line">            maxPos = right;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[maxPos]);</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="built_in">buildHeap</span>(arr);</span><br><span class="line">    <span class="comment">// 控制堆化的数量，每次交换完元素后要减1</span></span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶最大的元素与最后一个位置交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="comment">// 从堆顶开始往下堆化</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, <span class="number">0</span>, --k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么快排要比堆排序好？"><a href="#为什么快排要比堆排序好？" class="headerlink" title="为什么快排要比堆排序好？"></a>为什么快排要比堆排序好？</h2><ul>
<li><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/838a38286dcace89ca63895b77ae8ece.jpg" alt="img"></p>
</li>
<li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。 <strong>快速排序数据交换的次数不会比逆序度多。</strong> </p>
<p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/6e81fdde42ec3fd288d32eb866867fbd.jpg" alt="img"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>Redis缓存</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h1 id="旁路缓存：Redis是如何工作的？"><a href="#旁路缓存：Redis是如何工作的？" class="headerlink" title="旁路缓存：Redis是如何工作的？"></a>旁路缓存：<code>Redis</code>是如何工作的？</h1><p><code>Redis</code> 提供了高性能的数据存取功能，所以广泛应用在缓存场景中，既能有效地提升业务应用的响应速度，还可以避免把高并发大压力的请求发送到数据库层。但是，如果 <code>Redis</code> 做缓存时出现了问题，比如说缓存失效，那么，大量请求就会直接积压到数据库层，必然会给数据库带来巨大的压力，很可能会导致数据库宕机或是故障，那么，业务应用就没有办法存取数据、响应用户请求了。这种生产事故，肯定不是我们希望看到的。</p>
<p>正因为 <code>Redis</code> 用作缓存的普遍性以及它在业务应用中的重要作用，所以，我们需要系统地掌握缓存的一系列内容，包括工作原理、替换策略、异常处理和扩展机制。具体来说，我们需要解决四个关键问题：</p>
<ul>
<li><code>Redis</code> 缓存具体是怎么工作的？</li>
<li><code>Redis</code> 缓存如果满了，该怎么办？</li>
<li>为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？</li>
<li><code>Redis</code> 的内存毕竟有限，如果用快速的固态硬盘来保存数据，可以增加缓存的数据量，那么，<code>Redis</code> 缓存可以使用快速固态硬盘吗？</li>
</ul>
<span id="more"></span>

<h2 id="缓存的特征"><a href="#缓存的特征" class="headerlink" title="缓存的特征"></a>缓存的特征</h2><p><strong>为什么需要缓存？</strong></p>
<p>一个系统中的不同层之间的访问速度不一样，所以我们才需要缓存，这样就可以把一些需要频繁访问的数据放在缓存中，以加快它们的访问速度。</p>
<img src="https://static001.geekbang.org/resource/image/ac/9c/ac80f6e1714f3e1e8eabcfd8da3d689c.jpg" alt="img" style="zoom:25%;" />

<p>如果每次 CPU 处理数据时，都要从 ms 级别的慢速磁盘中读取数据，然后再进行处理，那么，CPU 只能等磁盘的数据传输完成。这样一来，高速的 CPU 就被慢速的磁盘拖累了，整个计算机系统的运行速度会变得非常慢。</p>
<p><strong>缓存特征：</strong></p>
<ul>
<li><p>缓存的第一个特征：在一个层次化的系统中，缓存一定是一个快速子系统，数据存在缓存中时，能避免每次从慢速子系统中存取数据。对应到互联网应用来说，<code>Redis</code> 就是快速子系统，而数据库就是慢速子系统了。</p>
</li>
<li><p>第二个特征：缓存系统的容量大小总是小于后端慢速系统的，我们不可能把所有数据都放在缓存系统中。</p>
</li>
</ul>
<p>缓存和后端慢速系统之间，必然存在数据写回和再读取的交互过程。简单来说，缓存中的数据需要按一定规则淘汰出去，写回后端系统，而新的数据又要从后端系统中读取进来，写入缓存。</p>
<h2 id="Redis-缓存处理请求的两种情况"><a href="#Redis-缓存处理请求的两种情况" class="headerlink" title="Redis 缓存处理请求的两种情况"></a><code>Redis</code> 缓存处理请求的两种情况</h2><p>把 <code>Redis</code> 用作缓存时，我们会把 <code>Redis</code> 部署在数据库的前端，业务应用在访问数据时，会先查询 <code>Redis</code> 中是否保存了相应的数据。此时，根据数据是否存在缓存中，会有两种情况。</p>
<ul>
<li>缓存命中：<code>Redis</code> 中有相应数据，就直接读取 <code>Redis</code>，性能非常快。</li>
<li>缓存缺失：<code>Redis</code> 中没有保存相应数据，就从后端数据库中读取数据，性能就会变慢。而且，一旦发生缓存缺失，为了让后续请求能从缓存中读取到数据，我们需要把缺失的数据写入 <code>Redis</code>，这个过程叫作缓存更新。缓存更新操作会涉及到保证缓存和数据库之间的数据一致性问题</li>
</ul>
<img src="https://static001.geekbang.org/resource/image/6b/3d/6b0b489ec0c1c5049c8df84d77fa243d.jpg" alt="img" style="zoom: 20%;" />

<p>使用 <code>Redis</code> 缓存时，我们基本有三个操作：</p>
<ul>
<li>应用读取数据时，需要先读取 <code>Redis</code>；</li>
<li>发生缓存缺失时，需要从数据库读取数据；</li>
<li>发生缓存缺失时，还需要更新缓存。+ </li>
</ul>
<h2 id="Redis-作为旁路缓存的使用操作"><a href="#Redis-作为旁路缓存的使用操作" class="headerlink" title="Redis 作为旁路缓存的使用操作"></a><code>Redis</code> 作为旁路缓存的使用操作</h2><p><code>Redis</code> 是一个独立的系统软件，和业务应用程序是两个软件，当我们部署了 <code>Redis</code> 实例后，它只会被动地等待客户端发送请求，然后再进行处理。所以，如果应用程序想要使用 <code>Redis</code> 缓存，我们就要在程序中增加相应的缓存操作代码。所以，我们也把 <code>Redis</code> 称为旁路缓存，也就是说，读取缓存、读取数据库和更新缓存的操作都需要在应用程序中来完成。</p>
<p>使用 <code>Redis</code> 缓存时，具体来说，我们需要在应用程序中增加三方面的代码：</p>
<ul>
<li>当应用程序需要读取数据时，我们需要在代码中显式调用 <code>Redis</code> 的 GET 操作接口，进行查询；</li>
<li>如果缓存缺失了，应用程序需要再和数据库连接，从数据库中读取数据；</li>
<li>当缓存中的数据需要更新时，我们也需要在应用程序中显式地调用 SET 操作接口，把更新的数据写入缓存。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">String cacheKey = “productid_11010003”;</span><br><span class="line">String cacheValue = redisCache.<span class="built_in">get</span>(cacheKey)；</span><br><span class="line"><span class="comment">//缓存命中</span></span><br><span class="line"><span class="keyword">if</span> ( cacheValue != <span class="literal">NULL</span>)</span><br><span class="line">   <span class="keyword">return</span> cacheValue;</span><br><span class="line"><span class="comment">//缓存缺失</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">   cacheValue = <span class="built_in">getProductFromDB</span>();</span><br><span class="line">   redisCache.<span class="built_in">put</span>(cacheValue)  <span class="comment">//缓存更新</span></span><br></pre></td></tr></table></figure>

<p>可以看到，为了使用缓存，Web 应用程序需要有一个表示缓存系统的实例对象 <code>redisCache</code>，还需要主动调用 <code>Redis</code> 的 GET 接口，并且要处理缓存命中和缓存缺失时的逻辑，例如在缓存缺失时，需要更新缓存。</p>
<p>在使用旁路缓存时，我们需要在应用程序中增加操作代码，增加了使用 <code>Redis</code> 缓存的额外工作量，但是，也正因为 <code>Redis</code> 是旁路缓存，是一个独立的系统，我们可以单独对 <code>Redis</code> 缓存进行扩容或性能优化。而且，只要保持操作接口不变，我们在应用程序中增加的代码就不用再修改了。</p>
<h2 id="缓存的类型"><a href="#缓存的类型" class="headerlink" title="缓存的类型"></a>缓存的类型</h2><p>按照 <code>Redis</code> 缓存是否接受写请求，我们可以把它分成只读缓存和读写缓存。先来了解下只读缓存。</p>
<h3 id="只读缓存"><a href="#只读缓存" class="headerlink" title="只读缓存"></a>只读缓存</h3><p>当 <code>Redis</code> 用作只读缓存时，应用要读取数据的话，会先调用 <code>Redis</code> GET 接口，查询数据是否存在。而所有的数据写请求，会直接发往后端的数据库，在数据库中增删改。对于删改的数据来说，如果 <code>Redis</code> 已经缓存了相应的数据，应用需要把这些缓存的数据删除，<code>Redis</code> 中就没有这些数据了。</p>
<p>当应用再次读取这些数据时，会发生缓存缺失，应用会把这些数据从数据库中读出来，并写到缓存中。这样一来，这些数据后续再被读取时，就可以直接从缓存中获取了，能起到加速访问的效果。</p>
<img src="https://static001.geekbang.org/resource/image/46/cd/464ea24a098c87b9d292cf61a2b2fecd.jpg" alt="img" style="zoom:20%;" />

<p>只读缓存直接在数据库中更新数据的好处是，所有最新的数据都在数据库中，而数据库是提供数据可靠性保障的，这些数据不会有丢失的风险。当我们需要缓存图片、短视频这些用户只读的数据时，就可以使用只读缓存这个类型了。</p>
<h3 id="读写缓存"><a href="#读写缓存" class="headerlink" title="读写缓存"></a>读写缓存</h3><p>对于读写缓存来说，除了读请求会发送到缓存进行处理（直接在缓存中查询数据是否存在)，所有的写请求也会发送到缓存，在缓存中直接对数据进行增删改操作。此时，得益于<code>Redis</code> 的高性能访问特性，数据的增删改操作可以在缓存中快速完成，处理结果也会快速返回给业务应用，这就可以提升业务应用的响应速度。</p>
<p>但是，和只读缓存不一样的是，在使用读写缓存时，最新的数据是在 <code>Redis</code> 中，而 <code>Redis</code> 是内存数据库，一旦出现掉电或宕机，内存中的数据就会丢失。这也就是说，应用的最新数据可能会丢失，给应用业务带来风险。</p>
<p>所以，根据业务应用对数据可靠性和缓存性能的不同要求，我们会有同步直写和异步写回两种策略。其中，<strong>同步直写策略优先保证数据可靠性，而异步写回策略优先提供快速响应。</strong></p>
<ul>
<li><p><strong>同步直写</strong>：写请求发给缓存的同时，也会发给后端数据库进行处理，等到缓存和数据库都写完数据，才给客户端返回。这样，即使缓存宕机或发生故障，最新的数据仍然保存在数据库中，这就提供了数据可靠性保证。同步直写会降低缓存的访问性能。这是因为缓存中处理写请求的速度是很快的，而数据库处理写请求的速度较慢。即使缓存很快地处理了写请求，也需要等待数据库处理完所有的写请求，才能给应用返回结果，这就增加了缓存的响应延迟。</p>
</li>
<li><p><strong>异步写回</strong>：优先考虑了响应延迟。此时，所有写请求都先在缓存中处理。等到这些增改的数据要被从缓存中淘汰出来时，缓存将它们写回后端数据库。这样一来，处理这些数据的操作是在缓存中进行的，很快就能完成。只不过，如果发生了掉电，而它们还没有被写回数据库，就会有丢失的风险了。</p>
</li>
</ul>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/009d055bb91d42c28b9316c649f87f66.jpg" alt="img" style="zoom:20%;" />

<p><strong>关于是选择只读缓存，还是读写缓存，主要看我们对写请求是否有加速的需求。</strong></p>
<ul>
<li><p>如果需要对写请求进行加速，我们选择读写缓存；</p>
</li>
<li><p>如果写请求很少，或者是只需要提升读请求的响应速度的话，我们选择只读缓存。</p>
</li>
</ul>
<p>举个例子，在商品大促的场景中，商品的库存信息会一直被修改。如果每次修改都需到数据库中处理，就会拖慢整个应用，此时，我们通常会选择读写缓存的模式。而在短视频 <code>App</code> 的场景中，虽然视频的属性有很多，但是，一般确定后，修改并不频繁，此时，在数据库中进行修改对缓存影响不大，所以只读缓存模式是一个合适的选择。</p>
<h2 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h2><p><strong><code>Redis</code> 只读缓存和使用直写策略的读写缓存，这两种缓存都会把数据同步写到后端数据库中，你觉得，它们有什么区别吗？</strong></p>
<p>1、使用只读缓存时，是先把修改写到后端数据库中，再把缓存中的数据删除。当下次访问这个数据时，会以后端数据库中的值为准，重新加载到缓存中。这样做的优点是，数据库和缓存可以保证完全一致，并且缓存中永远保留的是经常访问的热点数据。缺点是每次修改操作都会把缓存中的数据删除，之后访问时都会先触发一次缓存缺失，然后从后端数据库加载数据到缓存中，这个过程访问延迟会变大。</p>
<p>2、使用读写缓存时，是同时修改数据库和缓存中的值。这样做的优点是，被修改后的数据永远在缓存中存在，下次访问时，能够直接命中缓存，不用再从后端数据库中查询，这个过程拥有比较好的性能，比较适合先修改又立即访问的业务场景。但缺点是在高并发场景下，如果存在多个操作同时修改同一个值的情况，可能会导致缓存和数据库的不一致。</p>
<p>3、当使用只读缓存时，如果修改数据库失败了，那么缓存中的数据也不会被删除，此时数据库和缓存中的数据依旧保持一致。而使用读写缓存时，如果是先修改缓存，后修改数据库，如果缓存修改成功，而数据库修改失败了，那么此时数据库和缓存数据就不一致了。如果先修改数据库，再修改缓存，也会产生上面所说的并发场景下的不一致。</p>
<p><strong>总结</strong>：只读缓存是牺牲了一定的性能，优先保证数据库和缓存的一致性，它更适合对于一致性要求比较要高的业务场景。而如果对于数据库和缓存一致性要求不高，或者不存在并发修改同一个值的情况，那么使用读写缓存就比较合适，它可以保证更好的访问性能。</p>
<h1 id="替换策略：缓存满了怎么办？"><a href="#替换策略：缓存满了怎么办？" class="headerlink" title="替换策略：缓存满了怎么办？"></a>替换策略：缓存满了怎么办？</h1><p><code>Redis</code> 缓存使用内存来保存数据，避免业务应用从后端数据库中读取数据，可以提升应用的响应速度。那么，如果我们把所有要访问的数据都放入缓存，是不是一个很好的设计选择呢？其实，这样做的性价比反而不高。</p>
<p>举个例子吧。<code>MySQL</code> 中有 <code>1TB</code> 的数据，如果我们使用 <code>Redis</code> 把这 <code>1TB</code> 的数据都缓存起来，虽然应用都能在内存中访问数据了，但是，这样配置并不合理，因为性价比很低。一方面，<code>1TB</code> 内存的价格大约是 3.5 万元，而 <code>1TB</code> 磁盘的价格大约是 1000 元。另一方面，数据访问都是有局部性的，也就是我们通常所说的“八二原理”，80% 的请求实际只访问了 20% 的数据。所以，用 <code>1TB</code> 的内存做缓存，并没有必要。</p>
<p><strong>缓存数据的淘汰机制：</strong>简单来说，数据淘汰机制包括两步：<strong>第一，根据一定的策略，筛选出对应用访问来说“不重要”的数据；第二，将这些数据从缓存中删除，为新来的数据腾出空间，</strong></p>
<h2 id="设置多大的缓存容量合适？"><a href="#设置多大的缓存容量合适？" class="headerlink" title="设置多大的缓存容量合适？"></a>设置多大的缓存容量合适？</h2><p>缓存容量设置得是否合理，会直接影响到使用缓存的性价比。我们通常希望以最小的代价去获得最大的收益，所以，把昂贵的内存资源用在关键地方就非常重要了。</p>
<p>实际应用中的数据访问是具有局部性的。下面有一张图，图里有红、蓝两条线，显示了不同比例数据贡献的访问量情况。蓝线代表了“八二原理”表示的数据局部性，而红线则表示在当前应用负载下，数据局部性的变化。我们先看看蓝线。它表示的就是“八二原理”，有 20% 的数据贡献了 80% 的访问了，而剩余的数据虽然体量很大，但只贡献了 20% 的访问量。这 80% 的数据在访问量上就形成了一条长长的尾巴，我们也称为“长尾效应”。</p>
<img src="https://static001.geekbang.org/resource/image/98/e4/986ed247a4353524f387f0bbf76586e4.jpg" alt="img" style="zoom:20%;" />

<p>因为 20% 的数据不一定能贡献 80% 的访问量，我们不能简单地按照“总数据量的 20%”来设置缓存最大空间容量。在实践过程中，我看到过的缓存容量占总数据量的比例，从 5% 到 40% 的都有。这个容量规划不能一概而论，是需要结合应用数据实际访问特征和成本开销来综合考虑的。</p>
<p><strong>建议把缓存容量设置为总数据量的 15% 到 30%，兼顾访问性能和内存空间开销。</strong></p>
<p>对于 <code>Redis</code> 来说，一旦确定了缓存最大容量，比如 <code>4GB</code>，你就可以使用下面这个命令来设定缓存的大小了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">CONFIG SET maxmemory 4gb</span><br></pre></td></tr></table></figure>

<p><strong>缓存被写满是不可避免的。</strong>即使你精挑细选，确定了缓存容量，还是要面对缓存写满时的替换操作。缓存替换需要解决两个问题：决定淘汰哪些数据，如何处理那些被淘汰的数据。</p>
<h2 id="Redis-缓存有哪些淘汰策略？"><a href="#Redis-缓存有哪些淘汰策略？" class="headerlink" title="Redis 缓存有哪些淘汰策略？"></a><code>Redis</code> 缓存有哪些淘汰策略？</h2><p>内存淘汰策略如下：</p>
<img src="https://static001.geekbang.org/resource/image/04/f6/04bdd13b760016ec3b30f4b02e133df6.jpg" alt="img" style="zoom: 33%;" />

<ul>
<li><p>默认情况下，<code>Redis</code> 在使用的内存空间超过 <code>maxmemory</code> 值时，并不会淘汰数据，也就是设定的 <code>noeviction</code> 策略。对应到 <code>Redis</code> 缓存，也就是指，一旦缓存被写满了，再有写请求来时，<code>Redis</code> 不再提供服务，而是直接返回错误。<code>Redis</code> 用作缓存时，实际的数据集通常都是大于缓存容量的，总会有新的数据要写入缓存，这个策略本身不淘汰数据，也就不会腾出新的缓存空间，我们不把它用在 <code>Redis</code> 缓存中。</p>
</li>
<li><p>针对过期时间的数据：</p>
<ul>
<li><code>volatile-ttl</code> 在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li><code>volatile-random</code> 就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li><code>volatile-lru</code> 会使用 <code>LRU</code> 算法筛选设置了过期时间的键值对。</li>
<li><code>volatile-lfu</code> 会使用 <code>LFU</code> 算法选择设置了过期时间的键值对。</li>
</ul>
</li>
<li><p>针对所有数据：</p>
<ul>
<li><code>allkeys-random</code> 策略，从所有键值对中随机选择并删除数据；</li>
<li><code>allkeys-lru</code> 策略，使用 <code>LRU</code> 算法在所有数据中进行筛选。</li>
<li><code>allkeys-lfu</code> 策略，使用 <code>LFU</code> 算法在所有数据中进行筛选。</li>
</ul>
</li>
</ul>
<p>这也就是说，如果一个键值对被删除策略选中了，即使它的过期时间还没到，也需要被删除。当然，如果它的过期时间到了但未被策略选中，同样也会被删除。</p>
<p><code>LRU</code> 算法的全称是 Least Recently Used，从名字上就可以看出，<strong>这是按照最近最少使用的原则来筛选数据，最不常用的数据会被筛选出来，而最近频繁使用的数据会留在缓存中。</strong><code> LRU</code> 算法背后的想法非常朴素：它认为刚刚被访问的数据，肯定还会被再次访问，所以就把它放在 <code>MRU</code> 端；长久不访问的数据，肯定就不会再被访问了，所以就让它逐渐后移到 <code>LRU</code> 端，在缓存满时，就优先删除它。</p>
<p><strong>缺点：</strong> <code>LRU</code> 算法在实际实现时，需要用链表管理所有的缓存数据，这会带来额外的空间开销。而且，当有数据被访问时，需要在链表上把该数据移动到 <code>MRU</code> 端，如果有大量数据被访问，就会带来很多链表移动操作，会很耗时，进而会降低 <code>Redis</code> 缓存性能。</p>
<p><strong>解决：</strong> 在 <code>Redis</code> 中，<code>LRU</code> 算法被做了简化，以减轻数据淘汰对缓存性能的影响。具体来说，<code>Redis</code> 默认会记录每个数据的最近一次访问的时间戳（由键值对数据结构 <code>RedisObject</code> 中的 <code>lru</code> 字段记录）。然后，<code>Redis</code> 在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，<code>Redis</code> 会比较这 N 个数据的 <code>lru</code> 字段，把 <code>lru</code> 字段值最小的数据从缓存中淘汰出去。</p>
<p><code>Redis</code> 提供了一个配置参数 <code>maxmemory-samples</code>，这个参数就是 <code>Redis</code> 选出的数据个数 N。例如，我们执行如下命令，可以让 <code>Redis </code>选出 100 个数据作为候选数据集：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CONFIG SET maxmemory-samples 100</span><br></pre></td></tr></table></figure>

<p>当需要再次淘汰数据时，<code>Redis</code> 需要挑选数据进入第一次淘汰时创建的候选集合。这儿的挑选标准是：<strong>能进入候选集合的数据的 <code>lru</code> 字段值必须小于候选集合中最小的 <code>lru</code> 值。</strong>当有新数据进入候选数据集后，如果候选数据集中的数据个数达到了 <code>maxmemory-samples</code>，<code>Redis</code> 就把候选数据集中 <code>lru</code> 字段值最小的数据淘汰出去。</p>
<p><strong>三个使用建议：</strong></p>
<ul>
<li>优先使用<code> allkeys-lru</code> 策略。这样，可以充分利用<code> LRU</code> 这一经典缓存算法的优势，把最近最常访问的数据留在缓存中，提升应用的访问性能。如果你的业务数据中有明显的冷热数据区分，我建议你使用 <code>allkeys-lru</code> 策略。</li>
<li>如果业务应用中的数据访问频率相差不大，没有明显的冷热数据区分，建议使用 <code>allkeys-random</code> 策略，随机选择淘汰的数据就行。</li>
<li>如果你的业务中有置顶的需求，比如置顶新闻、置顶视频，那么，可以使用<code> volatile-lru</code> 策略，同时不给这些置顶数据设置过期时间。这样一来，这些需要置顶的数据一直不会被删除，而其他数据会在过期时根据 <code>LRU</code> 规则进行筛选。</li>
</ul>
<h2 id="如何处理被淘汰的数据？"><a href="#如何处理被淘汰的数据？" class="headerlink" title="如何处理被淘汰的数据？"></a>如何处理被淘汰的数据？</h2><p>一旦被淘汰的数据选定后，如果这个数据是干净数据，那么我们就直接删除；如果这个数据是脏数据，我们需要把它写回数据库</p>
<img src="https://static001.geekbang.org/resource/image/95/5e/953e48912yy9515abf9db588d447cc5e.jpg" alt="img" style="zoom:25%;" />

<p><strong>干净数据和脏数据的区别</strong>就在于，和最初从后端数据库里读取时的值相比，有没有被修改过。干净数据一直没有被修改，所以后端数据库里的数据也是最新值。在替换时，它可以被直接删除。</p>
<p>注意：<strong>对于 <code>Redis</code> 来说，它决定了被淘汰的数据后，会把它们删除。即使淘汰的数据是脏数据，<code>Redis</code> 也不会把它们写回数据库。</strong>所以，我们在使用 <code>Redis</code> 缓存时，如果数据被修改了，需要在数据修改时就将它写回数据库。否则，这个脏数据被淘汰时，会被 <code>Redis</code> 删除，而数据库里也没有最新的数据了。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><code>Redis</code> 缓存在应对脏数据时，需要在数据修改的同时，也把它写回数据库，针对我们上节课介绍的缓存读写模式：只读缓存，以及读写缓存中的两种写回策略，请你思考下，<code>Redis</code> 缓存对应哪一种或哪几种模式？</p>
<p>1、只读缓存模式：每次修改直接写入后端数据库，如果<code>Redis</code>缓存不命中，则什么都不用操作，如果<code>Redis</code>缓存命中，则删除缓存中的数据，待下次读取时从后端数据库中加载最新值到缓存中。</p>
<p>2、读写缓存模式+同步直写策略：由于<code>Redis</code>在淘汰数据时，直接在内部删除键值对，外部无法介入处理脏数据写回数据库，所以使用<code>Redis</code>作读写缓存时，只能采用同步直写策略，修改缓存的同时也要写入到后端数据库中，从而保证修改操作不被丢失。但这种方案在并发场景下会导致数据库和缓存的不一致，需要在特定业务场景下或者配合分布式锁使用。</p>
<h1 id="缓存异常（上）：如何解决缓存和数据库的数据不一致问题？"><a href="#缓存异常（上）：如何解决缓存和数据库的数据不一致问题？" class="headerlink" title="缓存异常（上）：如何解决缓存和数据库的数据不一致问题？"></a>缓存异常（上）：如何解决缓存和数据库的数据不一致问题？</h1><h2 id="缓存和数据库的数据不一致是如何发生的？"><a href="#缓存和数据库的数据不一致是如何发生的？" class="headerlink" title="缓存和数据库的数据不一致是如何发生的？"></a>缓存和数据库的数据不一致是如何发生的？</h2><p>“一致性”包含了两种情况：</p>
<ul>
<li>缓存中有数据，那么，缓存的数据值需要和数据库中的值相同；</li>
<li>缓存中本身没有数据，那么，数据库中的值必须是最新值。</li>
</ul>
<p>对于读写缓存来说，如果要对数据进行增删改，就需要在缓存中进行，同时还要根据采取的写回策略，决定是否同步写回到数据库中。</p>
<ul>
<li>同步直写策略：写缓存时，也同步写数据库，缓存和数据库中的数据一致；</li>
<li>异步写回策略：写缓存时不同步写数据库，等到数据从缓存中淘汰时，再写回数据库。<strong>使用这种策略时，如果数据还没有写回数据库，缓存就发生了故障，那么，此时，数据库就没有最新的数据了。</strong></li>
</ul>
<p>所以，对于读写缓存来说，要想保证缓存和数据库中的数据一致，就要采用同步直写策略。不过，需要注意的是，如果采用这种策略，就需要同时更新缓存和数据库。所以，我们要在业务应用中使用事务机制，来保证缓存和数据库的更新具有原子性，也就是说，两者要不一起更新，要不都不更新，返回错误信息，进行重试。否则，我们就无法实现同步直写。</p>
<p><strong>当然，在有些场景下，我们对数据一致性的要求可能不是那么高，比如说缓存的是电商商品的非关键属性或者短视频的创建或修改时间等，那么，我们可以使用异步写回策略。</strong></p>
<h3 id="只读缓存-1"><a href="#只读缓存-1" class="headerlink" title="只读缓存"></a>只读缓存</h3><p>对于只读缓存来说，如果有数据新增，会直接写入数据库；而有数据删改时，就需要把只读缓存中的数据标记为无效。这样一来，应用后续再访问这些增删改的数据时，因为缓存中没有相应的数据，就会发生缓存缺失。此时，应用再从数据库中把数据读入缓存，这样后续再访问数据时，就能够直接从缓存中读取了。</p>
<img src="https://static001.geekbang.org/resource/image/15/dc/15ae0147459ecc46436f35a0f3e5yydc.jpg" alt="img" style="zoom:20%;" />

<p>那么，这个过程中会不会出现数据不一致的情况呢？</p>
<ol>
<li><p><strong>新增数据</strong></p>
<p>如果是新增数据，数据会直接写到数据库中，不用对缓存做任何操作，此时，缓存中本身就没有新增数据，而数据库中是最新值，这种情况符合我们刚刚所说的一致性的第 2 种情况，所以，此时，缓存和数据库的数据是一致的。</p>
</li>
<li><p><strong>删改数据</strong></p>
<p>如果发生删改操作，应用既要更新数据库，也要在缓存中删除数据。这两个操作如果无法保证原子性，也就是说，要不都完成，要不都没完成，此时，就会出现数据不一致问题了。</p>
<ul>
<li><p><strong>应用先删除缓存，再更新数据库</strong>：如果缓存删除成功，但是数据库更新失败，那么，应用再访问数据时，缓存中没有数据，就会发生缓存缺失。然后，应用再访问数据库，但是数据库中的值为旧值，应用就访问到旧值了。</p>
<img src="https://static001.geekbang.org/resource/image/b3/ae/b305a6355c9da145e4d1f86d23f4f0ae.jpg" alt="img" style="zoom:20%;" /></li>
<li><p><strong>先更新数据库，再删除缓存中的值：</strong> 如果应用先完成了数据库的更新，但是，在删除缓存时失败了，那么，数据库中的值是新值，而缓存中的是旧值，这肯定是不一致的。这个时候，如果有其他的并发请求来访问数据，按照正常的缓存访问流程，就会先在缓存中查询，但此时，就会读到旧值了。</p>
<img src="https://static001.geekbang.org/resource/image/76/77/767b4b2b1bafffd9a4b6368f05930a77.jpg" alt="img" style="zoom:20%;" />

<p><strong>总结：</strong></p>
</li>
</ul>
<img src="https://static001.geekbang.org/resource/image/2c/ac/2c376b536aff9d14d8606499f401cdac.jpg" alt="img" style="zoom:25%;" /></li>
</ol>
<h2 id="如何解决数据不一致问题？"><a href="#如何解决数据不一致问题？" class="headerlink" title="如何解决数据不一致问题？"></a>如何解决数据不一致问题？</h2><ol>
<li><p><strong>重试机制</strong></p>
<p>可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如使用 Kafka 消息队列）。当应用没有能够成功地删除缓存值或者是更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。</p>
<p>如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，我们也可以保证数据库和缓存的数据一致了。否则的话，我们还需要再次进行重试。如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。</p>
</li>
</ol>
<p>下图显示了先更新数据库，再删除缓存值时，如果缓存删除失败，再次重试后删除成功的情况，你可以看下。</p>
<img src="https://static001.geekbang.org/resource/image/74/ab/74a66b9ce185d7c5b53986fc522dfcab.jpg" alt="img" style="zoom:20%;" />

<p>刚刚说的是在更新数据库和删除缓存值的过程中，其中一个操作失败的情况，实际上，即使这两个操作第一次执行时都没有失败，当有大量并发请求时，应用还是有可能读到不一致的数据。</p>
<h3 id="情况一：先删除缓存，再更新数据库。"><a href="#情况一：先删除缓存，再更新数据库。" class="headerlink" title="情况一：先删除缓存，再更新数据库。"></a>情况一：先删除缓存，再更新数据库。</h3><p>假设线程 A 删除缓存值后，还没有来得及更新数据库（比如说有网络延迟），线程 B 就开始读取数据了，那么这个时候，线程 B 会发现缓存缺失，就只能去数据库读取。这会带来两个问题：</p>
<ol>
<li>线程 B 读取到了旧值；</li>
<li>线程 B 是在缓存缺失的情况下读取的数据库，所以，它还会把旧值写入缓存，这可能会导致其他线程从缓存中读到旧值。</li>
</ol>
<p>等到线程 B 从数据库读取完数据、更新了缓存后，线程 A 才开始更新数据库，此时，缓存中的数据是旧值，而数据库中的是最新值，两者就不一致了。</p>
<img src="https://static001.geekbang.org/resource/image/85/12/857c2b5449d9a04de6fe93yy1e355c12.jpg" alt="img" style="zoom:20%;" />

<p><strong>解决：</strong> <strong>延迟双删：在线程 A 更新完数据库值以后，我们可以让它先 sleep 一小段时间，再进行一次缓存删除操作。</strong></p>
<p>之所以要加上 sleep 的这段时间，就是为了让线程 B 能够先从数据库读取数据，再把缺失的数据写入缓存，然后，线程 A 再进行删除。所以，线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间。这个时间怎么确定呢？建议你在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，以此为基础来进行估算。这样一来，其它线程读取数据时，会发现缓存缺失，所以会从数据库中读取最新值。因为这个方案会在第一次删除缓存值后，延迟一段时间再次进行删除，所以我们也把它叫做“延迟双删”。</p>
<h3 id="情况二：先更新数据库值，再删除缓存值。"><a href="#情况二：先更新数据库值，再删除缓存值。" class="headerlink" title="情况二：先更新数据库值，再删除缓存值。"></a>情况二：先更新数据库值，再删除缓存值。</h3><p>如果线程 A 删除了数据库中的值，但还没来得及删除缓存值，线程 B 就开始读取数据了，那么此时，线程 B 查询缓存时，发现缓存命中，就会直接从缓存中读取旧值。不过，在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读取到旧值。而且，线程 A 一般也会很快删除缓存值，这样一来，其他线程再次读取时，就会发生缓存缺失，进而从数据库中读取最新值。所以，<strong>这种情况对业务的影响较小。</strong></p>
<img src="https://static001.geekbang.org/resource/image/a1/0b/a1c66ee114yyc9f37f2a35f21b46010b.jpg" alt="img" style="zoom:20%;" />

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><img src="https://static001.geekbang.org/resource/image/11/6f/11ae5e620c63de76448bc658fe6a496f.jpg" alt="img" style="zoom: 25%;" />

<p>在大多数业务场景下，我们会把 <code>Redis</code> 作为只读缓存使用。针对只读缓存来说，我们既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存。我的建议是，优先使用先更新数据库再删除缓存的方法，原因主要有两个：</p>
<ol>
<li>先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；</li>
<li>如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。</li>
</ol>
<p>不过，当使用先更新数据库再删除缓存时，也有个地方需要注意，如果业务层要求必须读取一致的数据，那么，我们就需要在更新数据库时，先在 <code>Redis</code> 缓存客户端暂存并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。</p>
<h2 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h2><p>在只读缓存中进行数据的删改操作时，需要在缓存中删除相应的缓存值。我想请你思考一下，如果在这个过程中，我们不是删除缓存值，而是直接更新缓存的值，你觉得和删除缓存值相比，有什么好处和不足吗？</p>
<p>这种情况相当于把<code>Redis</code>当做读写缓存使用，删改操作同时操作数据库和缓存。</p>
<p>1、先更新数据库，再更新缓存：如果更新数据库成功，但缓存更新失败，此时数据库中是最新值，但缓存中是旧值，后续的读请求会直接命中缓存，得到的是旧值。</p>
<p>2、先更新缓存，再更新数据库：如果更新缓存成功，但数据库更新失败，此时缓存中是最新值，数据库中是旧值，后续读请求会直接命中缓存，但得到的是最新值，短期对业务影响不大。但是，一旦缓存过期或者满容后被淘汰，读请求就会从数据库中重新加载旧值到缓存中，之后的读请求会从缓存中得到旧值，对业务产生影响。</p>
<p>同样地，针对这种其中一个操作可能失败的情况，也可以使用重试机制解决，把第二步操作放入到消息队列中，消费者从消息队列取出消息，再更新缓存或数据库，成功后把消息从消息队列删除，否则进行重试，以此达到数据库和缓存的最终一致。</p>
<p>以上是没有并发请求的情况。如果存在并发读写，也会产生不一致，分为以下4种场景。</p>
<p>1、先更新数据库，再更新缓存，写+读并发：线程A先更新数据库，之后线程B读取数据，此时线程B会命中缓存，读取到旧值，之后线程A更新缓存成功，后续的读请求会命中缓存得到最新值。这种场景下，线程A未更新完缓存之前，在这期间的读请求会短暂读到旧值，对业务短暂影响。</p>
<p>2、先更新缓存，再更新数据库，写+读并发：线程A先更新缓存成功，之后线程B读取数据，此时线程B命中缓存，读取到最新值后返回，之后线程A更新数据库成功。这种场景下，虽然线程A还未更新完数据库，数据库会与缓存存在短暂不一致，但在这之前进来的读请求都能直接命中缓存，获取到最新值，所以对业务没影响。</p>
<p>3、先更新数据库，再更新缓存，写+写并发：线程A和线程B同时更新同一条数据，更新数据库的顺序是先A后B，但更新缓存时顺序是先B后A，这会导致数据库和缓存的不一致。</p>
<p>4、先更新缓存，再更新数据库，写+写并发：与场景3类似，线程A和线程B同时更新同一条数据，更新缓存的顺序是先A后B，但是更新数据库的顺序是先B后A，这也会导致数据库和缓存的不一致。</p>
<p>场景1和2对业务影响较小，场景3和4会造成数据库和缓存不一致，影响较大。也就是说，在读写缓存模式下，写+读并发对业务的影响较小，而写+写并发时，会造成数据库和缓存的不一致。</p>
<p>针对场景3和4的解决方案是，对于写请求，需要配合分布式锁使用。写请求进来时，针对同一个资源的修改操作，先加分布式锁，这样同一时间只允许一个线程去更新数据库和缓存，没有拿到锁的线程把操作放入到队列中，延时处理。用这种方式保证多个线程操作同一资源的顺序性，以此保证一致性。</p>
<p>综上，使用读写缓存同时操作数据库和缓存时，因为其中一个操作失败导致不一致的问题，同样可以通过消息队列重试来解决。而在并发的场景下，读+写并发对业务没有影响或者影响较小，而写+写并发时需要配合分布式锁的使用，才能保证缓存和数据库的一致性。</p>
<p>另外，读写缓存模式由于会同时更新数据库和缓存，优点是，缓存中一直会有数据，如果更新操作后会立即再次访问，可以直接命中缓存，能够降低读请求对于数据库的压力（没有了只读缓存的删除缓存导致缓存缺失和再加载的过程）。缺点是，如果更新后的数据，之后很少再被访问到，会导致缓存中保留的不是最热的数据，缓存利用率不高（只读缓存中保留的都是热数据），所以读写缓存比较适合用于读写相当的业务场景。</p>
<h1 id="缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？"><a href="#缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？" class="headerlink" title="缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？"></a>缓存异常（下）：如何解决缓存雪崩、击穿、穿透难题？</h1><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指大量的应用请求无法在 <code>Redis</code>缓存中进行处理，紧接着，应用将大量请求发送到数据库层，导致数据库层的压力激增。</p>
<ul>
<li><p><strong>第一个原因是：缓存中有大量数据同时过期，导致大量请求无法得到处理。</strong>具体来说，当数据保存在缓存中，并且设置了过期时间时，如果在某一个时刻，大量数据同时过期，此时，应用再访问这些数据的话，就会发生缓存缺失。紧接着，应用就会把请求发送给数据库，从数据库中读取数据。如果应用的并发请求量很大，那么数据库的压力也就很大，这会进一步影响到数据库的其他正常业务请求处理。</p>
<img src="https://static001.geekbang.org/resource/image/74/2e/74bb1aa4b2213e3ff29e2ee701e8f72e.jpg" alt="img" style="zoom:20%;" /></li>
</ul>
<p><strong>解决方案：</strong> </p>
<ul>
<li><p>首先，<strong>我们可以避免给大量的数据设置相同的过期时间</strong>。如果业务层的确要求有些数据同时失效，你可以在用 EXPIRE 命令给每个数据设置过期时间时，给这些数据的过期时间增加一个较小的随机数（例如，随机增加 1~3 分钟），这样一来，不同数据的过期时间有所差别，但差别又不会太大，既避免了大量数据同时过期，同时也保证了这些数据基本在相近的时间失效，仍然能满足业务需求。</p>
</li>
<li><p><strong>服务降级：</strong> </p>
<ul>
<li>当业务应用访问的是非核心数据（例如电商商品属性）时，暂时停止从缓存中查询这些数据，而是直接返回预定义信息、空值或是错误信息；</li>
<li>当业务应用访问的是核心数据（例如电商商品库存）时，仍然允许查询缓存，如果缓存缺失，也可以继续通过数据库读取。</li>
</ul>
<p>这样一来，只有部分过期数据的请求会发送到数据库，数据库的压力就没有那么大了</p>
<p>​    <img src="https://static001.geekbang.org/resource/image/4a/a8/4ab3be5ba24cf172879e6b2cff649ca8.jpg" alt="img" style="zoom:20%;" /></p>
</li>
<li><p><strong>第二个原因：<code>Redis</code> 缓存实例发生故障宕机了，无法处理请求，这就会导致大量请求一下子积压到数据库层，从而发生缓存雪崩。</strong></p>
<p>一般来说，一个 <code>Redis</code> 实例可以支持数万级别的请求处理吞吐量，而单个数据库可能只能支持数千级别的请求处理吞吐量，它们两个的处理能力可能相差了近十倍。由于缓存雪崩，<code>Redis</code> 缓存失效，所以，数据库就可能要承受近十倍的请求压力，从而因为压力过大而崩溃。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p><strong>在业务系统中实现服务熔断或请求限流机制。</strong></p>
<ul>
<li><p>服务熔断，是指在发生缓存雪崩时，为了防止引发连锁的数据库雪崩，甚至是整个系统的崩溃，我们暂停业务应用对缓存系统的接口访问。再具体点说，就是业务应用调用缓存接口时，缓存客户端并不把请求发给 <code>Redis</code> 缓存实例，而是直接返回，等到 <code>Redis</code> 缓存实例重新恢复服务后，再允许应用请求发送到缓存系统。</p>
<p>在业务系统运行时，我们可以监测 <code>Redis</code> 缓存所在机器和数据库所在机器的负载指标，例如每秒请求数、CPU 利用率、内存利用率等。如果我们发现 <code>Redis</code> 缓存实例宕机了，而数据库所在机器的负载压力突然增加（例如每秒请求数激增），此时，就发生缓存雪崩了。大量请求被发送到数据库进行处理。我们可以启动服务熔断机制，暂停业务应用对缓存服务的访问，从而降低对数据库的访问压力，如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/17/b5/17d39f6233c3332161c588b42eccaeb5.jpg" alt="img" style="zoom:20%;" />

<p><strong>缺点：</strong>服务熔断虽然可以保证数据库的正常运行，但是暂停了整个缓存系统的访问，对业务应用的影响范围大。为了尽可能减少这种影响，我们也可以进行请求限流。</p>
</li>
<li><p>请求限流，就是指，我们在业务系统的请求入口前端控制每秒进入系统的请求数，避免过多的请求被发送到数据库。</p>
<p>假设业务系统正常运行时，请求入口前端允许每秒进入系统的请求是 1 万个，其中，9000 个请求都能在缓存系统中进行处理，只有 1000 个请求会被应用发送到数据库进行处理。</p>
<p>一旦发生了缓存雪崩，数据库的每秒请求数突然增加到每秒 1 万个，此时，我们就可以启动请求限流机制，在请求入口前端只允许每秒进入系统的请求数为 1000 个，再多的请求就会在入口前端被直接拒绝服务。所以，使用了请求限流，就可以避免大量并发请求压力传递到数据库层。</p>
</li>
</ul>
<img src="https://static001.geekbang.org/resource/image/d5/54/d5a0928e1d97cae2f4a4fb5b93e5c854.jpg" alt="img" style="zoom:20%;" /></li>
<li><p><strong>事前预防。</strong></p>
<p>通过主从节点的方式构建 <code>Redis</code> 缓存高可靠集群。如果 <code>Redis</code> 缓存的主节点故障宕机了，从节点还可以切换成为主节点，继续提供缓存服务，避免了由于缓存实例宕机而导致的缓存雪崩问题。</p>
<p><strong>缓存雪崩是发生在大量数据同时失效的场景下，而接下来我要向你介绍的缓存击穿，是发生在某个热点数据失效的场景下。和缓存雪崩相比，缓存击穿失效的数据数量要小很多，应对方法也不一样，我们来看下。</strong></p>
</li>
</ul>
<h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指，针对某个访问非常频繁的热点数据的请求，无法在缓存中进行处理，紧接着，访问该数据的大量请求，一下子都发送到了后端数据库，导致了数据库压力激增，会影响数据库处理其他请求。缓存击穿的情况，经常发生在热点数据过期失效时，如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/d4/4b/d4c77da4yy7d6e34aca460642923ab4b.jpg" alt="img" style="zoom:20%;" />

<p><strong>解决方案：</strong> 为了避免缓存击穿给数据库带来的激增压力，我们的解决方法也比较直接，对于访问特别频繁的热点数据，我们就不设置过期时间了。这样一来，对热点数据的访问请求，都可以在缓存中进行处理，而 <code>Redis</code> 数万级别的高吞吐量可以很好地应对大量的并发请求访问。</p>
<h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指要访问的数据既不在 <code>Redis</code> 缓存中，也不在数据库中，导致请求在访问缓存时，发生缓存缺失，再去访问数据库时，发现数据库中也没有要访问的数据。此时，应用也无法从数据库中读取数据再写入缓存，来服务后续请求，这样一来，缓存也就成了“摆设”，如果应用持续有大量请求访问数据，就会同时给缓存和数据库带来巨大压力，如下图所示：</p>
<img src="https://static001.geekbang.org/resource/image/46/2e/46c49dd155665579c5204a66da8ffc2e.jpg" alt="img" style="zoom:20%;" />

<p>那么，缓存穿透会发生在什么时候呢？一般来说，有两种情况。</p>
<ul>
<li><p>业务层误操作：缓存中的数据和数据库中的数据被误删除了，所以缓存和数据库中都没有数据；</p>
</li>
<li><p>恶意攻击：专门访问数据库中没有的数据。</p>
</li>
</ul>
<p><strong>解决方案：</strong></p>
<ul>
<li><p><strong>第一种方案是，缓存空值或缺省值。</strong></p>
<ul>
<li>一旦发生缓存穿透，我们就可以针对查询的数据，在 <code>Redis</code> 中缓存一个空值或是和业务层协商确定的缺省值（例如，库存的缺省值可以设为 0）。紧接着，应用发送的后续请求再进行查询时，就可以直接从 <code>Redis</code> 中读取空值或缺省值，返回给业务应用了，避免了把大量请求发送给数据库处理，保持了数据库的正常运行。</li>
</ul>
</li>
<li><p><strong>第二种方案是，使用布隆过滤器快速判断数据是否存在，避免从数据库中查询数据是否存在，减轻数据库压力。</strong></p>
<ul>
<li>基于布隆过滤器的快速检测特性，我们可以在把数据写入数据库时，使用布隆过滤器做个标记。当缓存缺失后，应用查询数据库时，可以通过查询布隆过滤器快速判断数据是否存在。如果不存在，就不用再去数据库中查询了。这样一来，即使发生缓存穿透了，大量请求只会查询 <code>Redis</code> 和布隆过滤器，而不会积压到数据库，也就不会影响数据库的正常运行。布隆过滤器可以使用 <code>Redis</code> 实现，本身就能承担较大的并发访问压力。</li>
</ul>
</li>
<li><p><strong>最后一种方案是，在请求入口的前端进行请求检测。</strong></p>
<ul>
<li>缓存穿透的一个原因是有大量的恶意请求访问不存在的数据，所以，一个有效的应对方案是在请求入口前端，对业务系统接收到的请求进行合法性检测，把恶意的请求（例如请求参数不合理、请求参数是非法值、请求字段不存在）直接过滤掉，不让它们访问后端缓存和数据库。这样一来，也就不会出现缓存穿透问题了。</li>
</ul>
</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><img src="https://static001.geekbang.org/resource/image/b5/e1/b5bd931239be18bef24b2ef36c70e9e1.jpg" alt="img" style="zoom:20%;" />

<p>服务熔断、服务降级、请求限流这些方法都是属于“有损”方案，在保证数据库和整体系统稳定的同时，会对业务应用带来负面影响。例如使用服务降级时，有部分数据的请求就只能得到错误返回信息，无法正常处理。如果使用了服务熔断，那么，整个缓存系统的服务都被暂停了，影响的业务范围更大。而使用了请求限流机制后，整个业务系统的吞吐率会降低，能并发处理的用户请求会减少，会影响到用户体验。</p>
<p>所以，我给你的建议是，尽量使用预防式方案：</p>
<ul>
<li><p>针对缓存雪崩，合理地设置数据过期时间，以及搭建高可靠缓存集群；</p>
</li>
<li><p>针对缓存击穿，在缓存访问非常频繁的热点数据时，不要设置过期时间；</p>
</li>
<li><p>针对缓存穿透，提前在入口前端实现恶意请求检测，或者规范数据库的数据删除操作，避免误删除。</p>
</li>
</ul>
<h2 id="问题-2"><a href="#问题-2" class="headerlink" title="问题"></a>问题</h2><p>可以采用服务熔断、服务降级、请求限流的方法来应对缓存穿透问题吗？</p>
<p>需要区分场景来看。</p>
<p>如果缓存穿透的原因是恶意攻击，攻击者故意访问数据库中不存在的数据。这种情况可以先使用服务熔断、服务降级、请求限流的方式，对缓存和数据库层增加保护，防止大量恶意请求把缓存和数据库压垮。在这期间可以对攻击者进行防护，例如封禁IP等操作。</p>
<p>如果缓存穿透的原因是恶意攻击，攻击者故意访问数据库中不存在的数据。这种情况可以先使用服务熔断、服务降级、请求限流的方式，对缓存和数据库层增加保护，防止大量恶意请求把缓存和数据库压垮。在这期间可以对攻击者进行防护，例如封禁IP等操作。</p>
<p>如果缓存穿透的原因是，业务层误操作把数据从缓存和数据库都删除了，如果误删除的数据很少，不会导致大量请求压到数据库的情况，那么快速恢复误删的数据就好了，不需要使用服务熔断、服务降级、请求限流。如果误操作删除的数据范围比较广，导致大量请求压到数据库层，此时使用服务熔断、服务降级、请求限流的方法来应对是有帮助的，使用这些方法先把缓存和数据库保护起来，然后使用备份库快速恢复数据，在数据恢复期间，这些保护方法可以为数据库恢复提供保障。</p>
<p>还有一种缓存穿透的场景，我们平时会遇到的，和大家分享一下。</p>
<p>对于一个刚上线的新业务模块，如果还没有用户在这个模块内产生业务数据，当用户需要查询这个业务模块自己的数据时，由于缓存和数据库都没有这个用户的数据，此时也会产生缓存穿透，但这种场景不像误删数据和恶意攻击那样，而是属于正常的用户行为。</p>
<p>这种场景采用服务熔断、服务降级、请求限流的方式就没有任何意义了，反而会影响正常用户的访问。这种场景只能使用缓存回种空值、布隆过滤器来解决。</p>
<p>可见，服务熔断、服务降级、请求限流的作用是，当系统内部发生故障或潜在问题时，为了防止系统内部的问题进一步恶化，所以会采用这些方式对系统增加保护，待系统内部故障恢复后，可以依旧继续对外提供服务，这些方法属于服务治理的范畴，在任何可能导致系统故障的场景下，都可以选择性配合使用。</p>
<h1 id="缓存被污染了，该怎么办？"><a href="#缓存被污染了，该怎么办？" class="headerlink" title="缓存被污染了，该怎么办？"></a>缓存被污染了，该怎么办？</h1><p>我们应用 <code>Redis</code> 缓存时，如果能缓存会被反复访问的数据，那就能加速业务应用的访问。但是，如果发生了缓存污染，那么，缓存对业务应用的加速作用就减少了。</p>
<p><strong>缓存污染：</strong> 在一些场景下，有些数据被访问的次数非常少，甚至只会被访问一次。当这些数据服务完访问请求后，如果还继续留存在缓存中的话，就只会白白占用缓存空间。这种情况，就是缓存污染。</p>
<p><strong>弊端：</strong>当缓存污染不严重时，只有少量数据占据缓存空间，此时，对缓存系统的影响不大。但是，缓存污染一旦变得严重后，就会有大量不再访问的数据滞留在缓存中。如果这时数据占满了缓存空间，我们再往缓存中写入新数据时，就需要先把这些数据逐步淘汰出缓存，这就会引入额外的操作时间开销，进而会影响应用的性能。</p>
<h2 id="如何解决缓存污染问题？"><a href="#如何解决缓存污染问题？" class="headerlink" title="如何解决缓存污染问题？"></a>如何解决缓存污染问题？</h2><p>要解决缓存污染，我们也能很容易想到解决方案，那就是得把不会再被访问的数据筛选出来并淘汰掉。这样就不用等到缓存被写满以后，再逐一淘汰旧数据之后，才能写入新数据了。而哪些数据能留存在缓存中，是由缓存的淘汰策略决定的。</p>
<ul>
<li><p><strong><code>volatile-random</code> 和 <code>allkeys-random</code>：</strong>采用随机挑选数据的方式，来筛选即将被淘汰的数据。</p>
<ul>
<li>既然是随机挑选，那么 <code>Redis</code> 就不会根据数据的访问情况来筛选数据。如果被淘汰的数据又被访问了，就会发生缓存缺失。也就是说，应用需要到后端数据库中访问这些数据，降低了应用的请求响应速度。所以，<code>volatile-random</code> 和 <code>allkeys-random</code> 策略，在避免缓存污染这个问题上的效果非常有限。</li>
</ul>
</li>
<li><p><strong><code>volatile-ttl：</code></strong> 针对的是设置了过期时间的数据，把这些数据中剩余存活时间最短的筛选出来并淘汰掉。</p>
<ul>
<li>虽然 <code>volatile-ttl</code> 策略不再是随机选择淘汰数据了，但是剩余存活时间并不能直接反映数据再次访问的情况。所以，按照 <code>volatile-ttl</code> 策略淘汰数据，和按随机方式淘汰数据类似，也可能出现数据被淘汰后，被再次访问导致的缓存缺失问题。</li>
<li><strong>一种例外情况：</strong> 业务应用在给数据设置过期时间的时候，就明确知道数据被再次访问的情况，并根据访问情况设置过期时间。此时，<code>Redis</code> 按照数据的剩余最短存活时间进行筛选，是可以把不会再被访问的数据筛选出来的，进而避免缓存污染。例如，业务部门知道数据被访问的时长就是一个小时，并把数据的过期时间设置为一个小时后。这样一来，被淘汰的数据的确是不会再被访问了。</li>
</ul>
</li>
</ul>
<p><strong>小结：</strong> 小结下。除了在明确知道数据被再次访问的情况下，<code>volatile-ttl</code> 可以有效避免缓存污染。在其他情况下，<code>volatile-random、allkeys-random、volatile-ttl </code>这三种策略并不能应对缓存污染问题。</p>
<h2 id="LRU-缓存策略"><a href="#LRU-缓存策略" class="headerlink" title="LRU 缓存策略"></a><code>LRU</code> 缓存策略</h2><p><strong><code>LRU</code> 策略的核心思想：</strong>如果一个数据刚刚被访问，那么这个数据肯定是热数据，还会被再次访问。按照这个核心思想，<code>Redis</code> 中的<code> LRU</code> 策略，会在每个数据对应的 <code>RedisObject</code> 结构体中设置一个 <code>lru</code> 字段，用来记录数据的访问时间戳。在进行数据淘汰时，<code>LRU</code> 策略会在候选数据集中淘汰掉 <code>lru</code> 字段值最小的数据（也就是访问时间最久的数据）。</p>
<p>所以，在数据被频繁访问的业务场景中，<code>LRU</code> 策略的确能有效留存访问时间最近的数据。而且，因为留存的这些数据还会被再次访问，所以又可以提升业务应用的访问速度。</p>
<p><strong>弊端：</strong>但是，也正是因为只看数据的访问时间，使用 <code>LRU</code> 策略在处理扫描式单次查询操作时，无法解决缓存污染。<strong>所谓的扫描式单次查询操作，就是指应用对大量的数据进行一次全体读取，每个数据都会被读取，而且只会被读取一次。此时，因为这些被查询的数据刚刚被访问过，所以 <code>lru</code> 字段值都很大。</strong></p>
<p>在使用 <code>LRU</code> 策略淘汰数据时，这些数据会留存在缓存中很长一段时间，造成缓存污染。如果查询的数据量很大，这些数据占满了缓存空间，却又不会服务新的缓存请求，此时，再有新数据要写入缓存的话，还是需要先把这些旧数据替换出缓存才行，这会影响缓存的性能。</p>
<img src="https://static001.geekbang.org/resource/image/76/75/76909482d30097da81273f7bda18b275.jpg" alt="img" style="zoom:20%;" />

<h2 id="LFU-缓存策略的优化"><a href="#LFU-缓存策略的优化" class="headerlink" title="LFU 缓存策略的优化"></a><code>LFU</code> 缓存策略的优化</h2><p><code>LFU</code> 缓存策略是在 <code>LRU</code> 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 <code>LFU</code> 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，<code>LFU</code> 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。</p>
<p><strong>好处：</strong> 和那些被频繁访问的数据相比，扫描式单次查询的数据因为不会被再次访问，所以它们的访问次数不会再增加。因此，<code>LFU</code> 策略会优先把这些访问次数低的数据淘汰出缓存。这样一来，<code>LFU</code> 策略就可以避免这些数据对缓存造成污染了。</p>
<p><strong>为了避免操作链表的开销，<code>Redis</code> 在实现 <code>LRU</code> 策略时使用了两个近似方法：</strong></p>
<ul>
<li><code>Redis</code> 是用 <code>RedisObject</code> 结构来保存数据的，<code>RedisObject</code> 结构中设置了一个 <code>lru</code> 字段，用来记录数据的访问时间戳；</li>
<li><code>Redis</code> 并没有为所有的数据维护一个全局的链表，而是通过随机采样方式，选取一定数量（例如 10 个）的数据放入候选集合，后续在候选集合中根据 <code>lru</code> 字段值的大小进行筛选。</li>
</ul>
<p>在此基础上，**<code>Redis</code> 在实现 <code>LFU</code> 策略的时候，只是把原来 <code>24bit</code> 大小的 <code>lru</code> 字段，又进一步拆分成了两部分。**</p>
<ol>
<li><code>ldt 值：lru 字段的前 16bit，表示数据的访问时间戳；</code></li>
<li><code>counter 值：lru 字段的后 8bit，表示数据的访问次数。</code></li>
</ol>
<p>总结一下：当 <code>LFU</code> 策略筛选数据时，<code>Redis</code> 会在候选集合中，根据数据 <code>lru</code> 字段的后 <code>8bit</code> 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 <code>lru</code> 字段的前 <code>16bit</code> 值大小，选择访问时间最久远的数据进行淘汰。</p>
<p><strong>问题：<code>Redis</code> 只使用了 <code>8bit</code> 记录数据的访问次数，而 <code>8bit</code> 记录的最大值是 255，这样可以吗？</strong></p>
<p>在实际应用中，一个数据可能会被访问成千上万次。如果每被访问一次，counter 值就加 1 的话，那么，只要访问次数超过了 255，数据的 counter 值就一样了。在进行数据淘汰时，LFU 策略就无法很好地区分并筛选这些数据，反而还可能会把不怎么访问的数据留存在了缓存中。</p>
<p>例子：假设第一个数据 A 的累计访问次数是 256，访问时间戳是 202010010909，所以它的 counter 值为 255，而第二个数据 B 的累计访问次数是 1024，访问时间戳是 202010010810。如果 counter 值只能记录到 255，那么数据 B 的 counter 值也是 255。此时，缓存写满了，Redis 使用 LFU 策略进行淘汰。数据 A 和 B 的 counter 值都是 255，LFU 策略再比较 A 和 B 的访问时间戳，发现数据 B 的上一次访问时间早于 A，就会把 B 淘汰掉。但其实数据 B 的访问次数远大于数据 A，很可能会被再次访问。这样一来，使用 LFU 策略来淘汰数据就不合适了。</p>
<p>因此，<strong>在实现 LFU 策略时，Redis 并没有采用数据每被访问一次，就给对应的 counter 值加 1 的计数规则，而是采用了一个更优化的计数规则。</strong></p>
<p>简单来说，LFU 策略实现的计数规则是：每当数据被访问一次时，首先，用计数器当前的值乘以配置项 lfu_log_factor 再加 1，再取其倒数，得到一个 p 值；然后，把这个 p 值和一个取值范围在（0，1）间的随机数 r 值比大小，只有 p 值大于 r 值时，计数器才加 1。</p>
<p>使用了这种计算规则后，我们可以通过设置不同的 lfu_log_factor 配置项，来控制计数器值增加的速度，避免 counter 值很快就到 255 了。</p>
<img src="https://static001.geekbang.org/resource/image/8e/3e/8eafa57112b01ba0yyf93034ca109f3e.jpg" alt="img" style="zoom:25%;" />

<p><strong>正是因为使用了非线性递增的计数器方法，即使缓存数据的访问次数成千上万，LFU 策略也可以有效地区分不同的访问次数，从而进行合理的数据筛选。从刚才的表中，我们可以看到，当 lfu_log_factor 取值为 10 时，百、千、十万级别的访问次数对应的 counter 值已经有明显的区分了，所以，我们在应用 LFU 策略时，一般可以将 lfu_log_factor 取值为 10。</strong></p>
<p>应用负载的情况是很复杂的。在一些场景下，有些数据在短时间内被大量访问后就不会再被访问了。那么再按照访问次数来筛选的话，这些数据会被留存在缓存中，但不会提升缓存命中率。为此，Redis 在实现 LFU 策略时，还设计了一个 counter 值的衰减机制。</p>
<p>简单来说，<strong>LFU 策略使用衰减因子配置项 lfu_decay_time 来控制访问次数的衰减</strong>。LFU 策略会计算当前时间和数据最近一次访问时间的差值，并把这个差值换算成以分钟为单位。然后，LFU 策略再把这个差值除以 lfu_decay_time 值，所得的结果就是数据 counter 要衰减的值。</p>
<h2 id="问题-3"><a href="#问题-3" class="headerlink" title="问题"></a>问题</h2><p><strong>使用了 LFU 策略后，你觉得缓存还会被污染吗？</strong></p>
<p>被污染的概率取决于LFU的配置，也就是lfu-log-factor和lfu-decay-time参数。</p>
<p>1、根据LRU counter计数规则可以得出，counter递增的概率取决于2个因素：</p>
<p>a) counter值越大，递增概率越低<br>b) lfu-log-factor设置越大，递增概率越低</p>
<p>所以当访问次数counter越来越大时，或者lfu-log-factor参数配置过大时，counter递增的概率都会越来越低，这种情况下可能会导致一些key虽然访问次数较高，但是counter值却递增困难，进而导致这些访问频次较高的key却优先被淘汰掉了。</p>
<p>另外由于counter在递增时，有随机数比较的逻辑，这也会存在一定概率导致访问频次低的key的counter反而大于访问频次高的key的counter情况出现。</p>
<p>2、如果lfu-decay-time配置过大，则counter衰减会变慢，也会导致数据淘汰发生推迟的情况。</p>
<p>3、另外，由于LRU的ldt字段只采用了16位存储，其精度是分钟级别的，在counter衰减时可能会产生同一分钟内，后访问的key比先访问的key的counter值优先衰减，进而先被淘汰掉的情况。</p>
<p>可见，Redis实现的LFU策略，也是近似的LFU算法。Redis在实现时，权衡了内存使用、性能开销、LFU的正确性，通过复用并拆分lru字段的方式，配合算法策略来实现近似的结果，虽然会有一定概率的偏差，但在内存数据库这种场景下，已经做得足够好了。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
</search>
