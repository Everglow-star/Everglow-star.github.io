<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树</title>
    <url>/2021/07/12/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b7043bf29a253bb36221eaec62b2e129.jpg" alt="img"></p>
<p>这里面每个元素我们叫做“节点”；用来连接相邻节点之间的关系，我们叫做“父子关系”。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/220043e683ea33b9912425ef759556ae.jpg" alt="img"></p>
<p>A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p>
<p><strong>高度（Height）、深度（Depth）、层（Level</strong>）：</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4094a733986073fedb6b9d03f877d71e.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="img"></p>
<ul>
<li>高度：从下往上度量，从最底层开始计数，并且计数的起点是 0。</li>
<li>深度：从上往下度量，从根结点开始度量，并且计数起点也是 0。</li>
<li>层数：跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330162407118.png" alt="image-20210330162407118"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/18413c6597c2850b75367393b401ad60.jpg" alt="img"></p>
<h3 id="如何存储二叉树？"><a href="#如何存储二叉树？" class="headerlink" title="如何存储二叉树？"></a>如何存储二叉树？</h3><ul>
<li><p>基于指针或者引用的二叉链式存储法</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="img"></p>
</li>
<li><p>基于数组的顺序存储法。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/14eaa820cb89a17a7303e8847a412330.jpg" alt="img"></p>
</li>
</ul>
<p>如果节点 X 存储在数组中下标为 <code>i </code>的位置，下标为 <code>2 * i</code> 的位置存储的就是左子节点，下标为 <code>2 * i + 1</code> 的位置存储的就是右子节点。反过来，下标为 <code>i/2</code> 的位置存储就是它的父节点。</p>
<p><strong>完全二叉树：</strong> 如果某棵二叉树是一棵完全二叉树，那用 <strong>数组</strong> 存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
</li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
</li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
</li>
<li><p>层序遍历：利用队列来依次打印每一层的元素值。</p>
</li>
<li><p>时间复杂度：<code>O(n)</code></p>
</li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/ab103822e75b5b15c615b68560cb2416.jpg" alt="img"></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f3bb11b6d4a18f95aa19e11f22b99bae.jpg" alt="img"></p>
<h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><ul>
<li>先取根节点，如果它等于我们要查找的数据，那就返回。</li>
<li>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</li>
<li>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/96b3d86ed9b7c4f399e8357ceed0db2a.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binarySearchTree::isInBST</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInBST</span>(root-&gt;left, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入"></a>2.插入</h3><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<ul>
<li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
</li>
<li><p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/daa9fb557726ee6183c5b80222cfc5c5.jpg" alt="img"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">binarySearchTree::insertIntoBST</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h3><p>框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (roo-&gt;val &gt; key) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 1</strong> ：删除节点恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330165915530.png" alt="image-20210330165915530"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == null &amp;&amp; root-&gt;right == null)</span><br><span class="line">    <span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 2</strong>：删除节点只有一个非空子节点，那么它要让这个孩子接替自己的位置。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330170032244.png" alt="image-20210330170032244"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == null) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right == null) <span class="keyword">return</span> root-&gt;left;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 3</strong> ： 删除有两个子节点，麻烦了，为了不破坏 <code>BST</code> 的性质，必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。以第二种方式讲解。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330170203285.png" alt="image-20210330170203285"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != null &amp;&amp; root-&gt;right != null) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root-&gt;val = minNode-&gt;val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下，这个删除操作并不完美，因为我们一般不会通过 <code>root-&gt;val = minNode-&gt;val</code> 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p>
<h3 id="4-支持重复数据的二叉查找树"><a href="#4-支持重复数据的二叉查找树" class="headerlink" title="4.支持重复数据的二叉查找树"></a>4.支持重复数据的二叉查找树</h3><p>前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。 <strong>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？</strong></p>
<ul>
<li><p>第一种方法：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
</li>
<li><p>第二种方法：每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg" alt="img"></p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<p><img src="https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg" alt="img"></p>
<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
<p><img src="https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg" alt="img"></p>
<h3 id="5-二叉查找树的时间复杂度分析"><a href="#5-二叉查找树的时间复杂度分析" class="headerlink" title="5.二叉查找树的时间复杂度分析"></a>5.二叉查找树的时间复杂度分析</h3><p>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<p><img src="https://static001.geekbang.org/resource/image/e3/d9/e3d9b2977d350526d2156f01960383d9.jpg" alt="img"></p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？树的高度就等于最大层数减一，为了方便计算，我们转换成层来表</p>
<p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p>
<p><strong>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n &gt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L<span class="number">-2</span>)+<span class="number">1</span></span><br><span class="line">n &lt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L<span class="number">-2</span>)+<span class="number">2</span>^(L<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>借助等比数列的求和公式，我们可以计算出，L 的范围是<code>[log2(n+1), log2n +1]</code>。完全二叉树的层数小于等于 <code>log2n +1</code>，也就是说，完全二叉树的高度小于等于<code> log2n</code>。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/9b/dd9f5a4525f5029a8339c89ad1c8159b.jpg" alt="img"></p>
<p>最先被发明的平衡二叉查找树是<code>AVL</code>树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p>
<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树， <strong>它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</strong></p>
<p><strong>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</strong></p>
<p><strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</strong></p>
<p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比<code>log2n</code> 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，</p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的，下一节我们讲红黑树的实现的时候会讲到。这节我们暂时不考虑这一点，所以，在画图和讲解的时候，我将黑色的、空的叶子节点都省略掉了。</p>
<p><img src="https://static001.geekbang.org/resource/image/90/9a/903ee0dcb62bce2f5b47819541f9069a.jpg" alt="img"></p>
<h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
</search>
