<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>二叉树</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b7043bf29a253bb36221eaec62b2e129.jpg" alt="img"></p>
<span id="more"></span>

<p>这里面每个元素我们叫做“节点”；用来连接相邻节点之间的关系，我们叫做“父子关系”。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/220043e683ea33b9912425ef759556ae.jpg" alt="img"></p>
<p>A 节点就是 B 节点的父节点，B 节点是 A 节点的子节点。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为兄弟节点。我们把没有父节点的节点叫做根节点，也就是图中的节点 E。我们把没有子节点的节点叫做叶子节点或者叶节点，比如图中的 G、H、I、J、K、L 都是叶子节点。</p>
<p><strong>高度（Height）、深度（Depth）、层（Level</strong>）：</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4094a733986073fedb6b9d03f877d71e.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50f89510ad1f7570791dd12f4e9adeb4.jpg" alt="img"></p>
<ul>
<li>高度：从下往上度量，从最底层开始计数，并且计数的起点是 0。</li>
<li>深度：从上往下度量，从根结点开始度量，并且计数起点也是 0。</li>
<li>层数：跟深度的计算类似，不过，计数起点是 1，也就是说根节点位于第 1 层。</li>
</ul>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>二叉树，每个节点最多有两个“叉”，也就是两个子节点，分别是左子节点和右子节点。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330162407118.png" alt="image-20210330162407118"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/18413c6597c2850b75367393b401ad60.jpg" alt="img"></p>
<h3 id="如何存储二叉树？"><a href="#如何存储二叉树？" class="headerlink" title="如何存储二叉树？"></a>如何存储二叉树？</h3><ul>
<li><p>基于指针或者引用的二叉链式存储法</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/12cd11b2432ed7c4dfc9a2053cb70b8e.jpg" alt="img"></p>
</li>
<li><p>基于数组的顺序存储法。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/14eaa820cb89a17a7303e8847a412330.jpg" alt="img"></p>
</li>
</ul>
<p>如果节点 X 存储在数组中下标为 <code>i </code>的位置，下标为 <code>2 * i</code> 的位置存储的就是左子节点，下标为 <code>2 * i + 1</code> 的位置存储的就是右子节点。反过来，下标为 <code>i/2</code> 的位置存储就是它的父节点。</p>
<p><strong>完全二叉树：</strong> 如果某棵二叉树是一棵完全二叉树，那用 <strong>数组</strong> 存储无疑是最节省内存的一种方式。因为数组的存储方式并不需要像链式存储法那样，要存储额外的左右子节点的指针。</p>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><ul>
<li><p>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树。</p>
</li>
<li><p>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树。</p>
</li>
<li><p>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身。</p>
</li>
<li><p>层序遍历：利用队列来依次打印每一层的元素值。</p>
</li>
<li><p>时间复杂度：<code>O(n)</code></p>
</li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/ab103822e75b5b15c615b68560cb2416.jpg" alt="img"></p>
<h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树要求，在树中的任意一个节点，其左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f3bb11b6d4a18f95aa19e11f22b99bae.jpg" alt="img"></p>
<h3 id="1-查找"><a href="#1-查找" class="headerlink" title="1.查找"></a>1.查找</h3><ul>
<li>先取根节点，如果它等于我们要查找的数据，那就返回。</li>
<li>如果要查找的数据比根节点的值小，那就在左子树中递归查找；</li>
<li>如果要查找的数据比根节点的值大，那就在右子树中递归查找。</li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/96b3d86ed9b7c4f399e8357ceed0db2a.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">binarySearchTree::isInBST</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isInBST</span>(root-&gt;left, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-插入"><a href="#2-插入" class="headerlink" title="2.插入"></a>2.插入</h3><p>新插入的数据一般都是在叶子节点上，所以我们只需要从根节点开始，依次比较要插入的数据和节点的大小关系。</p>
<ul>
<li><p>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置；如果不为空，就再递归遍历右子树，查找插入位置。</p>
</li>
<li><p>同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/daa9fb557726ee6183c5b80222cfc5c5.jpg" alt="img"></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode * <span class="title">binarySearchTree::insertIntoBST</span><span class="params">(TreeNode *root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == val)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val)</span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val)</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-删除"><a href="#3-删除" class="headerlink" title="3.删除"></a>3.删除</h3><p>框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == key) &#123;</span><br><span class="line">        <span class="comment">// 找到啦，进行删除</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (roo-&gt;val &gt; key) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">deleteNode</span>(root-&gt;left, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val &lt; key) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 1</strong> ：删除节点恰好是末端节点，两个子节点都为空，那么它可以当场去世了。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330165915530.png" alt="image-20210330165915530"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left == null &amp;&amp; root-&gt;right == null)</span><br><span class="line">    <span class="keyword">return</span> null;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 2</strong>：删除节点只有一个非空子节点，那么它要让这个孩子接替自己的位置。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330170032244.png" alt="image-20210330170032244"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除了情况 1 之后</span></span><br><span class="line"><span class="keyword">if</span> (root-&gt;left == null) <span class="keyword">return</span> root-&gt;right;</span><br><span class="line"><span class="keyword">if</span> (root-&gt;right == null) <span class="keyword">return</span> root-&gt;left;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>case 3</strong> ： 删除有两个子节点，麻烦了，为了不破坏 <code>BST</code> 的性质，必须找到左子树中最大的那个节点，或者右子树中最小的那个节点来接替自己。以第二种方式讲解。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330170203285.png" alt="image-20210330170203285"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (root-&gt;left != null &amp;&amp; root-&gt;right != null) &#123;</span><br><span class="line">    <span class="comment">// 找到右子树的最小节点</span></span><br><span class="line">    TreeNode* minNode = <span class="built_in">getMin</span>(root-&gt;right);</span><br><span class="line">    <span class="comment">// 把 root 改成 minNode</span></span><br><span class="line">    root-&gt;val = minNode-&gt;val;</span><br><span class="line">    <span class="comment">// 转而去删除 minNode</span></span><br><span class="line">    root-&gt;right = <span class="built_in">deleteNode</span>(root-&gt;right, minNode-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意一下，这个删除操作并不完美，因为我们一般不会通过 <code>root-&gt;val = minNode-&gt;val</code> 修改节点内部的值来交换节点，而是通过一系列略微复杂的链表操作交换 <code>root</code> 和 <code>minNode</code> 两个节点。因为具体应用中，val 域可能会很大，修改起来很耗时，而链表操作无非改一改指针，而不会去碰内部数据。</p>
<h3 id="4-支持重复数据的二叉查找树"><a href="#4-支持重复数据的二叉查找树" class="headerlink" title="4.支持重复数据的二叉查找树"></a>4.支持重复数据的二叉查找树</h3><p>前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作卫星数据。 <strong>前面我们讲的二叉查找树的操作，针对的都是不存在键值相同的情况。那如果存储的两个对象键值相同，这种情况该怎么处理呢？</strong></p>
<ul>
<li><p>第一种方法：二叉查找树中每一个节点不仅会存储一个数据，因此我们通过链表和支持动态扩容的数组等数据结构，把值相同的数据都存储在同一个节点上。</p>
</li>
<li><p>第二种方法：每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，把这个新插入的数据当作大于这个节点的值来处理。</p>
</li>
</ul>
<p><img src="https://static001.geekbang.org/resource/image/3f/5f/3f59a40e3d927f567022918d89590a5f.jpg" alt="img"></p>
<p>当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是继续在右子树中查找，直到遇到叶子节点，才停止。这样就可以把键值等于要查找值的所有节点都找出来。</p>
<p><img src="https://static001.geekbang.org/resource/image/fb/ff/fb7b320efd59a05469d6d6fcf0c98eff.jpg" alt="img"></p>
<p>对于删除操作，我们也需要先查找到每个要删除的节点，然后再按前面讲的删除操作的方法，依次删除。</p>
<p><img src="https://static001.geekbang.org/resource/image/25/17/254a4800703d31612c0af63870260517.jpg" alt="img"></p>
<h3 id="5-二叉查找树的时间复杂度分析"><a href="#5-二叉查找树的时间复杂度分析" class="headerlink" title="5.二叉查找树的时间复杂度分析"></a>5.二叉查找树的时间复杂度分析</h3><p>图中第一种二叉查找树，根节点的左右子树极度不平衡，已经退化成了链表，所以查找的时间复杂度就变成了 O(n)。</p>
<p><img src="https://static001.geekbang.org/resource/image/e3/d9/e3d9b2977d350526d2156f01960383d9.jpg" alt="img"></p>
<p>不管操作是插入、删除还是查找，时间复杂度其实都跟树的高度成正比，也就是 O(height)。既然这样，现在问题就转变成另外一个了，也就是，如何求一棵包含 n 个节点的完全二叉树的高度？树的高度就等于最大层数减一，为了方便计算，我们转换成层来表</p>
<p>树的高度就等于最大层数减一，为了方便计算，我们转换成层来表示。从图中可以看出，包含 n 个节点的完全二叉树中，第一层包含 1 个节点，第二层包含 2 个节点，第三层包含 4 个节点，依次类推，下面一层节点个数是上一层的 2 倍，第 K 层包含的节点个数就是 2^(K-1)。</p>
<p><strong>不过，对于完全二叉树来说，最后一层的节点个数有点儿不遵守上面的规律了。它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">n &gt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L<span class="number">-2</span>)+<span class="number">1</span></span><br><span class="line">n &lt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L<span class="number">-2</span>)+<span class="number">2</span>^(L<span class="number">-1</span>)</span><br></pre></td></tr></table></figure>

<p>借助等比数列的求和公式，我们可以计算出，L 的范围是<code>[log2(n+1), log2n +1]</code>。完全二叉树的层数小于等于 <code>log2n +1</code>，也就是说，完全二叉树的高度小于等于<code> log2n</code>。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h3><p>平衡二叉树的严格定义是这样的：二叉树中任意一个节点的左右子树的高度相差不能大于 1。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树。</p>
<p><img src="https://static001.geekbang.org/resource/image/dd/9b/dd9f5a4525f5029a8339c89ad1c8159b.jpg" alt="img"></p>
<p>最先被发明的平衡二叉查找树是<code>AVL</code>树，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。</p>
<p>但是很多平衡二叉查找树其实并没有严格符合上面的定义（树中任意一个节点的左右子树的高度相差不能大于 1），比如我们下面要讲的红黑树， <strong>它从根节点到各个叶子节点的最长路径，有可能会比最短路径大一倍。</strong></p>
<p><strong>发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题。</strong></p>
<p><strong>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。</strong></p>
<p>所以，如果我们现在设计一个新的平衡二叉查找树，只要树的高度不比<code>log2n</code> 大很多（比如树的高度仍然是对数量级的），尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p>
<h3 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h3><p>红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树，</p>
<p>红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p>
<ul>
<li>根节点是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li>
<li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li>
</ul>
<p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是为了简化红黑树的代码实现而设置的，下一节我们讲红黑树的实现的时候会讲到。这节我们暂时不考虑这一点，所以，在画图和讲解的时候，我将黑色的、空的叶子节点都省略掉了。</p>
<p><img src="https://static001.geekbang.org/resource/image/90/9a/903ee0dcb62bce2f5b47819541f9069a.jpg" alt="img"></p>
<h3 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h3>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>堆</title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h1><ul>
<li><p>堆是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。</p>
</li>
<li><p>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。</p>
</li>
</ul>
<p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。</p>
<span id="more"></span>

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4c452a1ad3b2d152daa2727d06097099.jpg" alt="img" style="zoom: 50%;" />

<p>第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。</p>
<h1 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h1><p>完全二叉树比较适合用数组来存储。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4d349f57947df6590a2dd1364c3b0b1e.jpg" alt="img" style="zoom:50%;" />

<p>从图中我们可以看到，数组中下标为 i 的节点的左子节点，就是下标为 i∗2 的节点，右子节点就是下标为 i∗2+1 的节点，父节点就是下标为i/2 的节点。</p>
<h2 id="插入一个元素"><a href="#插入一个元素" class="headerlink" title="插入一个元素"></a>插入一个元素</h2><p><strong>堆化：</strong> 如果我们把新插入的元素放到堆的最后，你可以看我画的这个图，是不是不符合堆的特性了？于是，我们就需要进行调整，让其重新满足堆的特性，这个过程我们起了一个名字，就叫做 <strong>堆化</strong> （<code>heapify</code>）。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/e578654f930002a140ebcf72b11eb722.jpg" alt="img" style="zoom:50%;" />

<p>堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换。新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/e3744661e038e4ae570316bc862b2c0e.jpg" alt="img" style="zoom:50%;" />

<h2 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h2><p>假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们删除堆顶元素之后，就需要把第二大的元素放到堆顶，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。</p>
<p>这种堆化过程不满足完全二叉树。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/5916121b08da6fc0636edf1fc24b5a81.jpg" alt="img" style="zoom:50%;" />

<p>我们把最后一个节点放到堆顶，然后利用同样的父子节点对比方法。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。这就是 <strong>从上往下</strong> 的堆化方法。</p>
<p>因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/110d6f442e718f86d2a1d16095513260.jpg" alt="img" style="zoom:50%;" />

<p><strong>时间复杂度：</strong> 一个包含 n 个节点的完全二叉树，树的高度不会超过<code>logn</code>。堆化的过程是顺着节点所在路径比较交换的，所以堆化的时间复杂度跟树的高度成正比，也就是 <code>O(logn)</code>。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 <code>O(logn)</code>。</p>
<h1 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h1><h2 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1.建堆"></a>1.建堆</h2><p><strong>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。</strong></p>
<ul>
<li> <strong>思路一：</strong> 在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</li>
<li> <strong>思路二：</strong> 第二种实现思路，跟第一种截然相反，也是我这里要详细讲的。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</li>
</ul>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt="img" style="zoom:50%;" />

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/aabb8d15b1b92d5e040895589c60419d.jpg" alt="img" style="zoom:50%;" />

<p>我们对下标从 <code>n/2</code>开始到 1 的数据进行堆化，下标是<code>n/2 + 1</code>到<code> n</code> 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 <code>n / 2 + 1</code> 到 <code>n</code> 的节点都是叶子节点。</p>
<p><strong>时间复杂度：</strong> 每个节点堆化的时间复杂度是 <code>O(logn)</code>，那 <code>2n+1</code> 个节点堆化的总时间复杂度是不是就是<code> O(nlogn)</code> 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是<code> O(n)</code>。</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。 <strong>只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/899b9f1b40302c9bd5a7f77f042542d5.jpg" alt="img" style="zoom:50%;" />

<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f712f8a7baade44c39edde839cefcc09.jpg" alt="img" style="zoom:50%;" />

<p>把公式左右都乘以 2，就得到另一个公式 <code>S2</code>。我们将 <code>S2</code> 错位对齐，并且用 <code>S2 </code>减去 <code>S1</code>，可以得到 <code>S</code>。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/629328315decd96e349d8cb3940636df.jpg" alt="img" style="zoom:50%;" />

<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/46ca25edc69b556b967d2c62388b7436.jpg" alt="img" style="zoom:50%;" />

<p>因为 <code>h=log2n</code>，代入公式 <code>S</code>，就能得到 <code>S=O(n)</code>，所以，建堆的时间复杂度就是 <code>O(n)</code>。</p>
<h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。 <strong>我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</strong> </p>
<p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 <code>n</code> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <code>n−1</code> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <code>n−1</code> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <code>1</code> 的一个元素，排序工作就完成了。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/23958f889ca48dbb8373f521708408d1.jpg" alt="img" style="zoom:50%;" />

<p><strong>空间复杂度：</strong> 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。</p>
<p><strong>时间复杂度：</strong> 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 <code>O(n)</code>，排序过程的时间复杂度是 <code>O(nlogn)</code>，所以，堆排序整体的时间复杂度是 <code>O(nlogn)</code>。</p>
<p><strong>稳定性：</strong> 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
<h1 id="为什么快排要比堆排序好？"><a href="#为什么快排要比堆排序好？" class="headerlink" title="为什么快排要比堆排序好？"></a>为什么快排要比堆排序好？</h1><ul>
<li><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/838a38286dcace89ca63895b77ae8ece.jpg" alt="img" style="zoom:50%;" /></li>
<li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。 <strong>快速排序数据交换的次数不会比逆序度多。</strong> </p>
<p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/6e81fdde42ec3fd288d32eb866867fbd.jpg" alt="img" style="zoom:50%;" /></li>
</ul>
<h1 id="堆的应用"><a href="#堆的应用" class="headerlink" title="堆的应用"></a>堆的应用</h1><h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><p>队列最大的特性就是先进先出。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，优先级最高的，最先出队。</p>
<p>一个堆就可以看作一个优先级队列。很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p>
<h3 id="1-合并有序小文件"><a href="#1-合并有序小文件" class="headerlink" title="1. 合并有序小文件"></a>1. 合并有序小文件</h3><p>假设我们有 100 个小文件，每个文件的大小是 <code>100MB</code>，每个文件中存储的都是 <strong>有序</strong> 的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。这里就会用到优先级队列。</p>
<p>整体思路有点像归并排序中的合并函数。我们从这 100 个文件中，各取第一个字符串，放入数组中，然后比较大小，把最小的那个字符串放入合并后的大文件中，并从数组中删除。</p>
<p>假设，这个最小的字符串来自于 <code>13.txt</code> 这个小文件，我们就再从这个小文件取下一个字符串，放到数组中，重新比较大小，并且选择最小的放入合并后的大文件，将它从数组中删除。依次类推，直到所有的文件中的数据都放入到大文件为止。</p>
<p>这里我们用 <strong>数组</strong> 这种数据结构，来存储从小文件中取出来的字符串。 <strong>每次从数组中取最小字符串，都需要循环遍历整个数组，显然，这不是很高效。</strong> 有没有更加高效方法呢？</p>
<p>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 <code>O(logn)</code>，<code>n</code> 表示堆中的数据个数，这里就是 100。比原来数组存储的方式要高效很多。</p>
<h3 id="2-高性能定时器"><a href="#2-高性能定时器" class="headerlink" title="2.高性能定时器"></a>2.高性能定时器</h3><p>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b04656d27fd0ba112a38a28c892069e7.jpg" alt="img"></p>
<p><strong>轮询的缺点：</strong> 这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。</p>
<ol>
<li>我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。</li>
<li>定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。</li>
<li>这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到（T-1）秒这段时间里，定时器都不需要做任何事情。</li>
<li>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。</li>
<li>定时器既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表，性能也就提高了。</li>
</ol>
<h2 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h2><p>我把这种求 Top K 的问题抽象成两类。</p>
<ul>
<li><p>一类是针对静态数据集合，也就是说数据集合事先确定，不会再变。</p>
</li>
<li><p>另一类是针对动态数据集合，也就是说数据集合事先并不确定，有数据动态地加入到集合中。</p>
</li>
</ul>
<ol>
<li><p>针对静态数据，如何在一个包含 n 个数据的数组中，查找前 K 大数据呢？我们可以维护一个大小为 K 的小顶堆，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了。</p>
<p>遍历数组需要 <code>O(n)</code> 的时间复杂度，一次堆化操作需要<code> O(logK)</code> 的时间复杂度，所以最坏情况下，n 个元素都入堆一次，时间复杂度就是 <code>O(nlogK)</code>。</p>
</li>
<li><p>一个数据集合中有两个操作，一个是添加数据，另一个询问当前的前 K 大数据。</p>
<p>如果每次询问前 K 大数据，我们都基于当前的数据重新计算的话，那时间复杂度就是 <code>O(nlogK)</code>，n 表示当前的数据的大小。实际上，我们可以一直都维护一个 K 大小的小顶堆，当有数据被添加到集合中时，我们就拿它与堆顶的元素对比。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理。这样，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回给他。</p>
</li>
</ol>
<h3 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h3><p>如何求动态数据集合中的中位数。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/1809157fdd804dd40a6a795ec30acbb6.jpg" alt="img" style="zoom:50%;" />

<p>对于一组静态数据，中位数是固定的，我们可以先排序，第 n/2 个数据就是中位数。每次询问中位数的时候，我们直接返回这个固定的值就好了。所以，尽管排序的代价比较大，但是边际成本会很小。但是，如果我们面对的是 <strong>动态数据集合</strong> ，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。</p>
<p><strong>做法：</strong> 维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且小顶堆中的数据都大于大顶堆中的数据。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/08c29d3e014a4baf5f8148c2271e6099.jpg" alt="img" style="zoom:50%;" />

<p>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆；否则，我们就将这个新数据插入到小顶堆。</p>
<p>这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况：如果 n 是偶数，两个堆中的数据个数都是 <code>n/2</code>；如果 <code>n</code> 是奇数，大顶堆有<code> n/2+1</code> 个数据，小顶堆有 <code>n/2</code> 个数据。这个时候，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定。</p>
<p>实现在动态数据集合中求中位数的操作。插入数据因为需要涉及堆化，所以 <strong>时间复杂度</strong> 变成了 <code>O(logn)</code>，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以 <strong>时间复杂度</strong> 就是 O(1)。</p>
<p><strong>实际上可以利用堆来求任意比例的top，比如求前60%大的数据，方法与上面类似，只是维护大顶堆和小顶堆的相对大小变了。</strong></p>
<h1 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h1><ul>
<li><p>对于完全二叉树来说，下标从 <code>2n+1 到 n</code> 的都是叶子节点，这个结论是怎么推导出来的呢？</p>
<p>堆是完全二叉树，求最后的非叶子节点即是求最大的叶子节点的父节点。最大的叶子节点下标为<code>n</code>，他的父节点为<code>n/2</code>，这是最后一个非叶子节点，所以<code>n/2+1到n</code>都是叶子节点。</p>
</li>
<li><p>假设现在我们有一个包含 10 亿个搜索关键词的日志文件，如何快速获取到 Top 10 最热门的搜索关键词呢？假设内存为<code>1G</code>。</p>
<p>因为用户搜索的关键词，有很多可能都是重复的，所以我们首先要统计每个搜索关键词出现的频率。我们可以通过散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构，来记录关键词及其出现的次数。</p>
<ol>
<li>假设我们选用散列表。我们就顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，我们去散列表中查询。如果存在，我们就将对应的次数加一；如果不存在，我们就将它插入到散列表，并记录次数为 1。以此类推，等遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</li>
<li>然后，我们再根据前面讲的用堆求 Top K 的方法，建立一个大小为 10 的小顶堆，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。</li>
</ol>
<p><strong>漏洞：</strong> 10 亿的关键词还是很多的。我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 <code>5GB</code> 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而我们的机器只有 <code>1GB</code> 的可用内存空间，所以我们无法一次性将所有的搜索关键词加入到内存中。这个时候该怎么办呢？</p>
<p><strong>解决：</strong> 相同数据经过哈希算法得到的哈希值是一样的。</p>
<ol>
<li>我们可以根据哈希算法的这个特点，将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。我们创建 10 个空文件 00，01，02，……，09。我们遍历这 10 亿个关键词，并且通过某个哈希算法对其求哈希值，然后哈希值同 10 取模，得到的结果就是这个搜索关键词应该被分到的文件编号。</li>
<li>对这 10 亿个关键词分片之后，每个文件都只有 1 亿的关键词，去除掉重复的，可能就只有 1000 万个，每个关键词平均 50 个字节，所以总的大小就是 <code>500MB</code>。<code>1GB</code> 的内存完全可以放得下。</li>
<li>我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后取这 100 个关键词中，出现次数最多的 10 个关键词，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。</li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h1><p><strong>二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。</strong></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/8bce81259abf0e9a06f115e22586b829.jpg" alt="img"></p>
<p><strong>时间复杂度：</strong> 我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/d1e4fa1542e187184c87c545c2fe4794.jpg" alt="img"></p>
<p>可以看出来，这是一个等比数列。其中 <code>n/(2^k) = 1</code> 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，经过了 k 次区间缩小操作，时间复杂度就是 O(k)。通过 <code>n/(2^k) = 1</code>，我们可以求得 <code>k = log2n</code>，所以时间复杂度就是 <code>O(logn)</code>。</p>
<p><strong>注意：</strong> 用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，<code>O(1)</code> 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以， <strong>常量级时间复杂度的算法有时候可能还没有 <code>O(logn)</code> 的算法执行效率高。</strong></p>
<h1 id="递归与非递归实现"><a href="#递归与非递归实现" class="headerlink" title="递归与非递归实现"></a>递归与非递归实现</h1><ul>
<li><p>寻找一个数（基本的二分搜索）</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没找到返回-1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == target) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearchInternally</span>(a, mid+<span class="number">1</span>, high, target);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">bsearchInternally</span>(a, low, mid<span class="number">-1</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, <span class="keyword">int</span> n, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bsearchInternally</span>(a, <span class="number">0</span>, n - <span class="number">1</span>, target);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="二分查找的变形问题"><a href="#二分查找的变形问题" class="headerlink" title="二分查找的变形问题"></a>二分查找的变形问题</h1><p>有序数据集合中存在重复的数据</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/4221d02a2e88e9053085920f13f9ce36.jpg" alt="img"></p>
<h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/503c572dd0f9d734b55f1bd12765c4f8.jpg" alt="img"></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || nums[mid - <span class="number">1</span>] != target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 a[mid]等于要查找的值时，我们就需要确认一下这个 a[mid]是不是第一个值等于给定值的元素。</p>
<ul>
<li>如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；</li>
<li>如果 mid 不等于 0，但 a[mid]的前一个元素 a[mid-1]不等于 value，那也说明 a[mid]就是我们要找的第一个值等于给定值的元素。</li>
<li>如果经过检查之后发现 a[mid]前面的一个元素 a[mid-1]也等于 value，那说明此时的 a[mid]肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在[low, mid-1]之间。</li>
</ul>
<h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != target)</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>如果 a[mid]这个元素已经是数组中的最后一个元素了，那它肯定是我们要找的；如果 a[mid]的后一个元素 a[mid+1]不等于 value，那也说明 a[mid]就是我们要找的最后一个值等于给定值的元素。</p>
</li>
<li><p>如果我们经过检查之后，发现 a[mid]后面的一个元素 a[mid+1]也等于 value，那说明当前的这个 a[mid]并不是最后一个值等于给定值的元素。我们就更新 low=mid+1，因为要找的元素肯定出现在[mid+1, high]之间。</p>
</li>
</ul>
<h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch::firstBiggerSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果 a[mid]小于要查找的值 value，那要查找的值肯定在[mid+1, high]之间，所以，我们更新 low=mid+1。</li>
<li>对于 a[mid]大于等于给定值 value 的情况，我们要先看下这个 a[mid]是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid]前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid]就是我们要找的元素。</li>
<li>如果 a[mid-1]也大于等于要查找的值 value，那说明要查找的元素在[low, mid-1]之间，所以，我们将 high 更新为 mid-1。</li>
</ul>
<h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 寻找最后一个小于等于target的元素</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch::lastLessSearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mid == n - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h1><ul>
<li> <strong>二分查找依赖的是顺序表结构，简单点说就是数组。</strong> </li>
</ul>
<p>  那二分查找能否依赖其他数据结构呢？比如链表。答案是不可以的，主要原因是二分查找算法需要按照下标随机访问元素。数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。二分查找只能用在数据是通过顺序表来存储的数据结构上。如果你的数据是通过其他数据结构存储的，则无法应用二分查找。</p>
<ul>
<li><p> <strong>二分查找针对的是有序数据。</strong></p>
</li>
<li><p>静态数据：没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。</p>
</li>
<li><p>动态数据：如果我们的数据集合有频繁的插入和删除操作，要想用二分查找，要么每次插入、删除操作之后保证数据仍然有序，要么在每次二分查找之前都先进行排序。针对这种动态数据集合，无论哪种方法，维护有序的成本都是很高的。</p>
</li>
<li><p> <strong>数据量太小不适合二分查找。</strong></p>
</li>
</ul>
<p>  如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。只有数据量比较大的时候，二分查找的优势才会比较明显。</p>
<p>  如果数据之间的比较操作非常耗时，不管数据量大小，推荐使用二分查找。比如很长的字符串比较</p>
<ul>
<li> <strong>数据量太大也不适合二分查找。</strong></li>
</ul>
<p>  二分查找的底层需要依赖数组这种数据结构，而数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻。比如，我们有 <code>1GB</code> 大小的数据，如果希望用数组来存储，那就需要 <code>1GB</code> 的连续内存空间。</p>
<ul>
<li>二分查找更适合用在“近似”查找问题，在这类问题上，二分查找的优势更加明显。</li>
</ul>
<h1 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h1><h2 id="链表二分查找复杂度"><a href="#链表二分查找复杂度" class="headerlink" title="链表二分查找复杂度"></a>链表二分查找复杂度</h2><p>如果数据使用链表存储，二分查找的时间复杂就会变得很高，那查找的时间复杂度究竟是多少呢？</p>
<p>假设链表长度为n，二分查找每次都要找到中间点(计算中忽略奇偶数差异):</p>
<p>第一次查找中间点，需要移动指针n/2次；</p>
<p>第二次，需要移动指针n/4次；</p>
<p>第三次需要移动指针n/8次；<br>……<br>以此类推，一直到1次为值</p>
<p>总共指针移动次数(查找次数) = n/2 + n/4 + n/8 + …+ 1，这显然是个等比数列，根据等比数列求和公式：Sum = n - 1.</p>
<p>最后算法时间复杂度是：O(n-1)，忽略常数，记为<code>O(n)</code>，时间复杂度和顺序查找时间复杂度相同</p>
<p>但是稍微思考下，在二分查找的时候，由于要进行多余的运算，严格来说，会比顺序查找时间慢</p>
<h2 id="如何编程实现“求一个数的平方根”？要求精确到小数点后-6-位。"><a href="#如何编程实现“求一个数的平方根”？要求精确到小数点后-6-位。" class="headerlink" title="如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。"></a>如何编程实现“求一个数的平方根”？要求精确到小数点后 6 位。</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">rootbinarysearch</span><span class="params">(<span class="keyword">double</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(num == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">double</span> lower = <span class="number">1</span>, upper = num, curValue;</span><br><span class="line">    <span class="keyword">if</span>(lower &gt; upper)</span><br><span class="line">        std::<span class="built_in">swap</span>(lower,upper);</span><br><span class="line">	<span class="keyword">while</span>(upper-lower &gt; <span class="number">0.00000001</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		curValue = lower+(upper-lower)/<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">if</span>(curValue*curValue &lt; num)</span><br><span class="line">			lower = curValue;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			upper = curValue;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> curValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="如何在-1000-万个整数中快速查找某个整数？"><a href="#如何在-1000-万个整数中快速查找某个整数？" class="headerlink" title="如何在 1000 万个整数中快速查找某个整数？"></a>如何在 1000 万个整数中快速查找某个整数？</h2><p>假设内存限制是 <code>100MB</code>，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 <code>80MB</code>，符合内存的限制。我们可以先对这 1000 万数据从小到大排序，然后再利用二分查找算法，就可以快速地查找想要的数据了。</p>
<p><strong>用散列表或二叉树行么？</strong></p>
<p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，我们后面会讲，不管是散列表还是二叉树，都会需要比较多的额外的内存空间。如果用散列表或者二叉树来存储这 1000 万的数据，用 <code>100MB</code> 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p>
<h2 id="如何快速定位IP对应的省份地址？"><a href="#如何快速定位IP对应的省份地址？" class="headerlink" title="如何快速定位IP对应的省份地址？"></a>如何快速定位<code>IP</code>对应的省份地址？</h2><ol>
<li>如果 <code>IP</code> 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 <code>IP</code> 从小到大排序。如何来排序呢？我们知道，<code>IP</code> 地址可以转化为 32 位的整型数。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</li>
<li>当我们要查询某个 <code>IP</code> 归属地时，我们可以先通过二分查找，找到最后一个起始 <code>IP</code> 小于等于这个 <code>IP</code> 的 <code>IP</code> 区间</li>
<li>然后，检查这个 <code>IP</code> 是否在这个 <code>IP</code> 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</li>
</ol>
<h2 id="循环有序数组的查找"><a href="#循环有序数组的查找" class="headerlink" title="循环有序数组的查找"></a>循环有序数组的查找</h2><p>如果有序数组是一个循环有序数组，比如 4，5，6，1，2，3。针对这种情况，如何实现一个求“值等于给定值”的二分查找算法呢？</p>
<p>循环数组性质：以数组中间点为分区，数组分成一个有序数组和一个循环有序数组。</p>
<p>如果首元素 arr[low] &lt; arr[mid]，左半部分：<strong>有序**，右半部分：循环有序；<br>如果首元素 arr[low] &gt; arr[mid]，右半部分：</strong>有序<strong>，左半部分：循环有序；<br>判断查找的数是否在</strong>有序**的半边范围内，更新上下限<br>时间复杂度为 <code>O(logN)</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch::circleBinarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123; <span class="comment">// 转折点在右边，左边有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[left] &lt;= target &amp;&amp; target &lt; nums[mid])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    <span class="comment">// 转折点在左边，右边有序</span></span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &lt; target &amp;&amp; target &lt;= nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h1><p>因为二分查找底层依赖的是数组随机访问的特性，所以只能用数组来实现。如果数据存储在链表中，就真的没法用二分查找算法了吗？实际上，我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做 <strong>跳表（Skip list）</strong> 。</p>
<h2 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)。</p>
<p><img src="https://static001.geekbang.org/resource/image/e1/6d/e18303fcedc068e5a168de04df956f6d.jpg" alt="img"></p>
<p>那怎么来提高查找效率呢？如果像图中那样，对链表建立一级“索引”，查找起来是不是就会更快一些呢？每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做索引或索引层。图中的 down 表示 down 指针，指向下一级结点。</p>
<p><img src="https://static001.geekbang.org/resource/image/14/8e/14753c824a5ee4a976ea799727adc78e.jpg" alt="img"></p>
<p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，原来如果要查找 16，需要遍历 10 个结点， <strong>现在只需要遍历 7 个结点。</strong></p>
<p><strong>加了一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了。那如果我们再加一级索引呢？效率会不会提升更多呢？</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/49/65/492206afe5e2fef9f683c7cff83afa65.jpg" alt="img"></p>
<p>现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了。</p>
<p><img src="https://static001.geekbang.org/resource/image/46/a9/46d283cd82c987153b3fe0c76dfba8a9.jpg" alt="img"></p>
<p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点，速度是不是提高了很多？所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后， <strong>查找效率的提升就会非常明显。</strong></p>
<h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>在一个单链表中查询某个数据的时间复杂度是 O(n)。那在一个具有多级索引的跳表中，查询某个数据的时间复杂度是多少呢？</p>
<p>按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，<strong>第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k级索引结点的个数就是 n/(2^k)。</strong></p>
<p>假设索引有 h 级，最高级的索引有 2 个结点。通过上面的公式，我们可以得到 <code>n/(2^h)=2</code>，从而求得 <code>h=log2n-1</code>。如果包含原始链表这一层，整个跳表的高度就是 <code>log2n</code>。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 <code>O(m*logn)</code>。</p>
<p><strong>那这个 m 的值是多少呢？</strong> 按照前面这种索引结构，我们每一级索引都最多只需要遍历 3 个结点，也就是说 m=3，为什么是 3 呢？我来解释一下。</p>
<p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 K-1 级索引中最多只需要遍历 3 个结点，依次类推，每一级索引都最多只需要遍历 3 个结点。</p>
<p><img src="https://static001.geekbang.org/resource/image/d0/0c/d03bef9a64a0368e6a0d23ace8bd450c.jpg" alt="img"></p>
<p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找，是不是很神奇？不过，天下没有免费的午餐，这种查询效率的提升，前提是建立了很多级索引。</p>
<h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列。</p>
<p><img src="https://static001.geekbang.org/resource/image/10/55/100e9d6e5abeaae542cf7841be3f8255.jpg" alt="img"></p>
<p>这几级索引的结点总和就是 n/2+n/4+n/8…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。那我们有没有办法降低索引占用的内存空间呢？</p>
<p>如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？</p>
<p><img src="https://static001.geekbang.org/resource/image/0b/f7/0b0680ecf500f9349fc142e1a9eb73f7.jpg" alt="img"></p>
<p>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列。</p>
<p><img src="https://static001.geekbang.org/resource/image/19/95/192c480664e35591360cee96ff2f8395.jpg" alt="img"></p>
<p>通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要减少了一半的索引结点存储空间。</p>
<p><strong>实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以当对象比索引结点大很多时，那索引占用的额外空间就可以忽略了。</strong></p>
<h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>实际上，跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 <code>O(logn)</code>。</p>
<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 <code>O(logn)</code>。</p>
<p><img src="https://static001.geekbang.org/resource/image/65/6c/65379f0651bc3a7cfd13ab8694c4d26c.jpg" alt="img"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以在查找要删除的结点的时候，一定要获取前驱结点。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p>
<h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当我们不停地往跳表中插入数据时，如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况。极端情况下，跳表还会退化成单链表。</p>
<p><img src="https://static001.geekbang.org/resource/image/c8/c5/c863074c01c26538cf0134eaf8dc67c5.jpg" alt="img"></p>
<p>作为一种动态数据结构，我们需要某种手段来维护索引与原始链表大小之间的平衡，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。</p>
<p><strong>跳表是通过随机函数来维护前面提到的“平衡性”。</strong></p>
<p>当我们往跳表中插入数据的时候，我们可以选择同时将这个数据插入到部分索引层中。如何选择加入哪些索引层呢？</p>
<p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如随机函数生成了值 K，那我们就将这个结点添加到第一级到第 K 级这 K 级索引中。</p>
<p><img src="https://static001.geekbang.org/resource/image/a8/a7/a861445d0b53fc842f38919365b004a7.jpg" alt="img"></p>
<h2 id="为什么-Redis-要用跳表来实现有序集合，而不是红黑树？"><a href="#为什么-Redis-要用跳表来实现有序集合，而不是红黑树？" class="headerlink" title="为什么 Redis 要用跳表来实现有序集合，而不是红黑树？"></a>为什么 <code>Redis</code> 要用跳表来实现有序集合，而不是红黑树？</h2><p><code>Redis</code> 中的有序集合是通过跳表来实现的，严格点讲，其实还用到了散列表。</p>
<p><code>Redis</code> 中的有序集合支持的核心操作主要有下面这几个：</p>
<ul>
<li>插入一个数据；</li>
<li>删除一个数据；</li>
<li>查找一个数据；</li>
<li>按照区间查找数据（比如查找值在[100, 356]之间的数据）；</li>
<li>迭代输出有序序列。</li>
</ul>
<p><strong>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。</strong></p>
<p><strong>对于按照区间查找数据这个操作，跳表可以做到 <code>O(logn) </code>的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</strong></p>
<p>当然，<code>Redis</code> 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p>
<p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以在开发中，如果你想使用跳表，必须要自己实现。</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="链表（上）"><a href="#链表（上）" class="headerlink" title="链表（上）"></a>链表（上）</h1><h2 id="链表结构"><a href="#链表结构" class="headerlink" title="链表结构"></a>链表结构</h2><ul>
<li><p>数组需要一块 <strong>连续</strong> 的内存空间来存储，链表恰恰相反，它并 <strong>不需要一块连续</strong> 的内存空间，它通过“指针”将一组零散的内存块串联起来使用。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210324155924249.png" alt="image-20210324155924249" style="zoom: 50%;" /></li>
<li><p> <strong>链表类型：</strong> 单链表、双向链表和循环链表。</p>
</li>
<li><p><strong>单链表：</strong> 链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的<strong>“结点”</strong>。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b93e7ade9bb927baad1348d9a806ddeb.jpg" alt="img" style="zoom:50%;" />

<ul>
<li><strong>插入，删除：</strong> 只需要考虑相邻结点的指针改变，所以对应的时间复杂度是 O(1)。</li>
</ul>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/452e943788bdeea462d364389bd08a17.jpg" alt="img" style="zoom: 50%;" />

<ul>
<li><strong>查找：</strong> 根据指针一个结点一个结点地依次遍历，直到找到相应的结点，<strong>需要 O(n) 的时间复杂度。</strong></li>
</ul>
</li>
<li><p><strong>循环链表：</strong> 循环链表的尾结点指针是指向链表的头结点。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/86cb7dc331ea958b0a108b911f38d155.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>优点：循环链表的优点是从链尾到链头比较方便。当要处理的数据<strong>具有环型结构特点</strong>时，就特别适合采用循环链表。</li>
</ul>
</li>
<li><p><strong>双向链表：</strong> 支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 <code>prev</code> 指向前面的结点。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/cbc8ab20276e2f9312030c313a9ef70b.jpg" alt="img" style="zoom:50%;" />

<ul>
<li>如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性，<strong>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点</strong>，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</li>
</ul>
</li>
<li><p><strong>双向循环链表：</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104205.jpeg" alt="img" style="zoom: 50%;" /></li>
<li><p><strong>链表的删除操作：</strong>双向链表的优势</p>
<ul>
<li>删除结点中“值等于某个给定值”的结点：<ul>
<li>不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。<strong>删除O(1)，查找O(n)，总时间复杂度为O(n)</strong></li>
</ul>
</li>
<li>删除给定指针指向的结点：<ul>
<li>我们已经找到了要删除的结点，但是删除某个结点 q 需要知道其前驱结点，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。</li>
<li>因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了！</li>
<li>插入、删除操作有优势之外，对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="链表-VS-数组性能大比拼"><a href="#链表-VS-数组性能大比拼" class="headerlink" title="链表 VS 数组性能大比拼"></a>链表 VS 数组性能大比拼</h2><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104247.jpeg" alt="img" style="zoom:50%;" />

<h1 id="链表（下）"><a href="#链表（下）" class="headerlink" title="链表（下）"></a>链表（下）</h1><p>写链表代码注意的问题：</p>
<ul>
<li><p><strong>理解指针或引用的含义</strong></p>
</li>
<li><p><strong>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</strong></p>
</li>
<li><p><strong>警惕指针丢失和内存泄漏</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313104919.jpeg" alt="img" style="zoom:50%;" /></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">x-&gt;next = b;</span><br><span class="line">a-&gt;next = x;</span><br></pre></td></tr></table></figure>

<p>删除链表结点时，也一定要记得手动释放内存空间。</p>
<ul>
<li><p><strong>利用哨兵简化实现难度</strong></p>
<ul>
<li><p>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理。</p>
</li>
<li><p>如果我们引入 <strong>哨兵结点</strong> ，在任何时候，不管链表是不是空，head 指针都会一直指向这个哨兵结点。我们也把这种有哨兵结点的链表叫带头链表。相反，没有哨兵结点的链表就叫作不带头链表。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313105116.jpeg" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
<li><p><strong>重点留意边界条件处理</strong></p>
<ul>
<li>如果链表为空时，代码是否能正常工作？</li>
<li>如果链表只包含一个结点时，代码是否能正常工作？</li>
<li>如果链表只包含两个结点时，代码是否能正常工作？</li>
<li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li>
</ul>
</li>
</ul>
<p><strong>必会代码：</strong></p>
<ul>
<li>实现单链表、循环链表、双向链表，支持增删操作</li>
<li>实现单链表反转</li>
<li>实现两个有序的链表合并为一个有序链表</li>
<li>实现求链表的中间结点</li>
<li>链表中环的检测</li>
<li>删除链表倒数第 n 个结点</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="如何分析一个排序算法？"><a href="#如何分析一个排序算法？" class="headerlink" title="如何分析一个排序算法？"></a>如何分析一个排序算法？</h1><h2 id="1-排序算法的执行效率"><a href="#1-排序算法的执行效率" class="headerlink" title="1. 排序算法的执行效率"></a>1. 排序算法的执行效率</h2><ul>
<li> <strong>最好情况、最坏情况、平均情况时间复杂度</strong> </li>
<li>分别给出排序算法 <strong>三种情况</strong> 的时间复杂度</li>
<li>同时给出三种情况时间复杂度对应的 <strong>原始数据</strong> 是什么样的？</li>
<li> <strong>时间复杂度的系数、常数 、低阶</strong></li>
<li>时间复杂度反映的是数据规模 n **很大 **的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。</li>
<li>实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模 <strong>很小</strong> 的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。</li>
<li> <strong>比较次数和交换（或移动）次数</strong> ：基于 <strong>比较</strong> 的排序算法执行过程中，会涉及两种操作。</li>
<li> <strong>元素比较大小</strong> </li>
<li> <strong>元素交换或移动</strong> </li>
</ul>
<h2 id="2-排序算法的内存消耗"><a href="#2-排序算法的内存消耗" class="headerlink" title="2. 排序算法的内存消耗"></a>2. 排序算法的内存消耗</h2><p>算法的内存消耗可以通过空间复杂度来衡量，排序算法也不例外。不过，针对排序算法的空间复杂度，我们还引入了一个新的概念，原地排序（Sorted in place）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p>
<h2 id="3-排序算法的稳定性"><a href="#3-排序算法的稳定性" class="headerlink" title="3. 排序算法的稳定性"></a>3. 排序算法的稳定性</h2><ul>
<li><p> <strong>概念</strong> ：如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p>
</li>
<li><p> <strong>为什么要考察算法的稳定性？</strong></p>
</li>
<li><p>真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们需要按照对象的某个 key 来排序。</p>
</li>
<li><blockquote>
<p>举例：我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。对于这样一个排序需求，我们怎么来做呢？</p>
<ul>
<li>解法一：我们先按照金额对订单数据进行排序，然后，再遍历排序之后的订单数据，对于每个金额相同的小区间再按照下单时间排序。这种排序思路理解起来不难，但是实现起来会很复杂。</li>
<li>解法二：我们先按照下单时间给订单排序，注意是按照 <strong>下单时间</strong> ，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。为什么呢？</li>
<li> <strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变。</strong> 第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序。</li>
</ul>
</blockquote>
</li>
</ul>
<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h1><ul>
<li><p> <strong>思想</strong> ：冒泡操作 <strong>只会操作相邻的两个数据</strong> 。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系，如果不满足就让它俩交换。 <strong>一次冒泡操作会至少让一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。</strong> </p>
</li>
<li><p> <strong>优化：</strong> 当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作。另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了。</p>
</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E5%86%92%E6%B3%A1%E4%BC%98%E5%8C%96.jpg"></p>
<ul>
<li> <strong>代码</strong> </li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::BubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;			</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; j++) &#123;   <span class="comment">// j+1&lt;n-i, 每次冒泡之后都有一个元素被排序到正确位置（末尾）</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;			<span class="comment">// 注意：没有等号，保证了稳定性</span></span><br><span class="line">                <span class="keyword">int</span> temp = arr[j + <span class="number">1</span>];</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">                arr[j] = temp;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="literal">false</span>)      <span class="comment">// 没有数据交换提前退出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>性能分析：</strong> </li>
<li>冒泡排序是 <strong>原地排序算法</strong> 。冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。</li>
<li>冒泡排序是 <strong>稳定的算法</strong> 。在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性， <strong>当有相邻的两个元素大小相等的时候，我们不做交换</strong> ，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。</li>
<li>时间复杂度：<ul>
<li> <strong>最好情况时间复杂度：</strong> 排序数据已经 <strong>有序</strong> 。我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是   <strong>O(n)</strong> 。</li>
<li> <strong>最坏情况时间复杂度：</strong> 排序数据 <strong>完全倒序</strong> 。我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 <strong>O(n^2)</strong> 。</li>
<li> <strong>平均情况时间复杂度：</strong> <strong>O(n^2)</strong> 。</li>
</ul>
</li>
</ul>
<h1 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h1><ul>
<li><p> <strong>思想：</strong> 一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们只要遍历数组，找到数据应该插入的位置将其插入即可。</p>
</li>
<li><p> <strong>操作：</strong> 我们将数组中的数据分为两个区间， <strong>已排序区间</strong> 和 <strong>未排序区间</strong> 。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是 <strong>取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。</strong> 重复这个过程，直到未排序区间中元素为空，算法结束。</p>
</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F.jpg"></p>
<ul>
<li> <strong>代码1：</strong> </li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::InsertionSort1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &gt;= <span class="number">1</span>; j--) &#123;      <span class="comment">// j-1&gt;=0, i+1&lt;n</span></span><br><span class="line">            <span class="comment">// 注意没有=，即当等于是什么都不做，此时新插入的元素在与其相等的元素之后，保证了相同元素前后顺序不变</span></span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = arr[j];</span><br><span class="line">                arr[j] = arr[j - <span class="number">1</span>];</span><br><span class="line">                arr[j - <span class="number">1</span>] = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li> <strong>代码2：</strong> 相比第一种赋值操作只需要一步，下面更优。</li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::InsertionSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = arr[i];     <span class="comment">// 要插入的值</span></span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; j&gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; value)</span><br><span class="line">                arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[j + <span class="number">1</span>] = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p> <strong>性能分析：</strong> </p>
</li>
<li><p>插入排序是 <strong>原地排序算法</strong> 。</p>
</li>
<li><p>插入排序是 <strong>稳定的排序算法</strong> 。对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
</li>
<li><p> <strong>时间复杂度</strong> ：    +  <strong>最好情况时间复杂度：</strong> 如果要排序的数据已经是 <strong>有序</strong> 的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，每次只需要比较一个数据就能确定插入的位置。所以这种情况下，最好是时间复杂度为  <strong>O(n)</strong> 。注意，这里是 <strong>从尾到头遍历已经有序的数据</strong> 。    + <strong>最坏情况时间复杂度：</strong> 如果数组是 <strong>倒序</strong> 的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 <strong>O(n^2)</strong> 。    + <strong>平均情况时间复杂度：</strong>  <strong>数组中插入一个数据的平均时间复杂度是 O(n)。</strong> 所以，对于插入排序来说，每次插入操作都相当于在数组中插入一个数据，循环执行 n 次插入操作，所以平均时间复杂度为 <strong>O(n^2)</strong> 。</p>
</li>
</ul>
<h1 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h1><ul>
<li> <strong>思想：</strong> 选择排序每次会从未排序区间中 <strong>找到最小的元素</strong> ，将其放到已排序区间的 <strong>末尾</strong> 。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F.jpg"></p>
<ul>
<li> <strong>代码：</strong> </li>
</ul>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::SelectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> min = INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> min_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; min) &#123;</span><br><span class="line">                min = arr[j];</span><br><span class="line">                min_index = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当j == i时说明它就在正确的位置，不需要交换，不然会多一次操作。</span></span><br><span class="line">        <span class="keyword">if</span> (j != i) &#123;</span><br><span class="line">            <span class="keyword">int</span> tmp = arr[i];</span><br><span class="line">            arr[i] = min;</span><br><span class="line">            arr[min_index] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>算法性能分析：</strong> </p>
<p> <strong>性能分析：</strong> </p>
</li>
<li><p>选择排序是 <strong>原地排序算法</strong> 。</p>
</li>
<li><p>选择排序是 <strong>稳定的排序算法</strong> 。对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p>
</li>
<li><p> <strong>时间复杂度</strong> ：    +  <strong>最好情况时间复杂度：</strong> 如果要排序的数据已经是 <strong>有序</strong> 的，我们并不需要搬移任何数据。但是每一次操作都需要找到最小值，且不需要交换，时间复杂度为O(n)，总共需要n次操作，所以最好时间复杂度为  <strong>O(n^2)</strong> 。    + <strong>最坏情况时间复杂度：</strong> 如果数组是 <strong>倒序</strong> 的，每次操作需要找到最小值，且需要交换，时间复杂度为O(n)，所以最坏情况时间复杂度为 <strong>O(n^2)</strong> 。    + <strong>平均情况时间复杂度：</strong> <strong>O(n^2)</strong> 。</p>
</li>
</ul>
<blockquote>
<p> <strong>插入排序和冒泡排序的时间复杂度都是O(n^2)，为什么在实际中插入排序比冒泡排序更受欢迎呢？</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">冒泡排序中数据的交换操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">	<span class="keyword">int</span> tmp = a[j];</span><br><span class="line">   	a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">   	a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">   	flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">插入排序中数据的移动操作：</span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">  	a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">  	<span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。</p>
</blockquote>
<h1 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h1><ul>
<li><p><strong>分治思想：</strong> 如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了。 <strong>分治算法一般都是用递归来实现的，分治是一种解决问题的处理思想，递归是一种编程技巧。</strong> </p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.jpg"></p>
</li>
<li><p> <strong>分析：</strong> </p>
</li>
<li><p> <strong>递推公式：</strong> </p>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+<span class="number">1</span>…r))</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r 不用再继续分解</span><br></pre></td></tr></table></figure>

merge_sort(p…r) 表示，给下标从 p 到 r 之间的数组排序。我们将这个排序问题转化为了两个子问题，merge_sort(p…q) 和 merge_sort(q+1…r)，其中下标 q 等于 p 和 r 的中间位置，也就是 (p+r)/2。当下标从 p 到 q 和从 q+1 到 r 这两个子数组都排好序之后，我们再将两个有序的子数组合并在一起，这样下标从 p 到 r 之间的数据就也排好序了。
</code></pre>
<ul>
<li> <strong>整体框架：</strong> </li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 归并排序算法, A是数组，n表示数组大小</span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 递归调用函数</span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  // 递归终止条件</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  // 取p到r之间的中间位置q</span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  // 分治递归</span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  // 将A[p...q]和A[q+<span class="number">1.</span>..r]合并为A[p...r]</span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

merge(A[p...r], A[p...q], A[q+1...r]) 这个函数的作用就是，将已经有序的 A[p...q]和 A[q+1....r]合并成一个有序的数组，并且放入 A[p....r]。
</code></pre>
<ul>
<li> <strong>merge:</strong> 申请一个临时数组 temp，大小与 A[p…r]相同。我们用两个游标 i 和 j，分别指向 A[p…q]和 A[q+1…r]的第一个元素。比较这两个元素 A[i]和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i]放入到临时数组 temp，并且 i 后移一位，否则将 A[j]放入到数组 temp，j 后移一位。</li>
</ul>
<pre><code>![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/merge.jpg)
</code></pre>
<ul>
<li> <strong>代码：</strong> </li>
</ul>
<pre><code><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::MergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">MergeSortC</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::MergeSortC</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">MergeSortC</span>(arr, lo, mid);</span><br><span class="line">    <span class="built_in">MergeSortC</span>(arr, mid + <span class="number">1</span>, hi);		<span class="comment">// 注意要加1</span></span><br><span class="line">    <span class="built_in">merge</span>(arr, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = hi - lo + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;              <span class="comment">// index为temp的下标</span></span><br><span class="line">    <span class="keyword">int</span> i = lo, j = mid + <span class="number">1</span>;    <span class="comment">// i，j代表两个子数组的下标，注意不是从0开始</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</span><br><span class="line">        <span class="comment">// 如果arr[i]比arr[j]小，则把它arr[i]放进去</span></span><br><span class="line">        temp[index++] = arr[i] &lt;= arr[j] ? arr[i++] : arr[j++];	<span class="comment">// 注意：这里写等于，保证了稳定性</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) &#123;</span><br><span class="line">        temp[index++] = arr[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) &#123;</span><br><span class="line">        temp[index++] = arr[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; len; index++) &#123;</span><br><span class="line">        arr[lo++] = temp[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li><p><strong>性能分析：</strong> </p>
<ul>
<li><p>归并排序是 <strong>稳定的排序算法</strong> 。在合并的过程中，如果 A[p…q]和 A[q+1…r]之间有值相同的元素， <strong>先把 A[p…q]中的元素放入 temp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变</strong> 。所以，归并排序是一个稳定的排序算法。</p>
</li>
<li><p><strong>时间复杂度</strong> ：</p>
<ul>
<li> <strong>递推公式：</strong> </li>
</ul>
  <figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">T(<span class="number">1</span>) = C；   n=<span class="number">1</span>时，只需要常量级的执行时间，所以表示为C。</span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n； n&gt;<span class="number">1</span>	// T(n)代表对n的元素进行排序的时间，则分解成两个子数组排序的时间是T(n/<span class="number">2</span>)。</span><br><span class="line">	 = <span class="number">2</span>*(<span class="number">2</span>*T(n/<span class="number">4</span>) + n/<span class="number">2</span>) + n = <span class="number">4</span>*T(n/<span class="number">4</span>) + <span class="number">2</span>*n </span><br><span class="line">	 = <span class="number">4</span>*(<span class="number">2</span>*T(n/<span class="number">8</span>) + n/<span class="number">4</span>) + <span class="number">2</span>*n = <span class="number">8</span>*T(n/<span class="number">8</span>) + <span class="number">3</span>*n </span><br><span class="line">	 = <span class="number">8</span>*(<span class="number">2</span>*T(n/<span class="number">16</span>) + n/<span class="number">8</span>) + <span class="number">3</span>*n = <span class="number">16</span>*T(n/<span class="number">16</span>) + <span class="number">4</span>*n ...... </span><br><span class="line">	 = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k * n</span><br><span class="line">当n/<span class="number">2</span>^k=<span class="number">1</span>时，k=log2n, 则T(n) = cn + nlog2n;</span><br></pre></td></tr></table></figure>

<p>  从推导过程来看，归并排序的时间复杂度与有序度无关，所以不管是最好情况、最坏情况，还是平均情况，时间复杂度都是  <strong>O(nlogn)</strong> 。</p>
</li>
<li><p> <strong>空间复杂度：</strong> </p>
</li>
</ul>
<p>  按照正常分析逻辑，空间复杂度分析与时间复杂度递推公式一样，也是O(nlogn)。递归代码的空间复杂度并不能像时间复杂度那样累加。 <strong>尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。</strong> 在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是  <strong>O(n)</strong> 。</p>
</li>
</ul>
<h1 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h1><ul>
<li> <strong>思想：</strong> 如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 pivot（分区点）。我们遍历 p 到 r 之间的数据，将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分， <strong>前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的</strong> 。</li>
</ul>
<p>  <img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/%E5%BF%AB%E6%8E%921.jpg"></p>
<ul>
<li><p> <strong>分析：</strong> </p>
</li>
<li><p> <strong>递推公式：</strong> </p>
</li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">递推公式：</span><br><span class="line">quick_sort(p…r) = quick_sort(p…q-<span class="number">1</span>) + quick_sort(q+<span class="number">1</span>… r)</span><br><span class="line"></span><br><span class="line">终止条件：</span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> <strong>整体框架：</strong> </li>
</ul>
<pre><code><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">// 快速排序，A是数组，n表示数组的大小</span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">  quick_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line">// 快速排序递归函数，p,r为下标</span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">  </span><br><span class="line">  q = partition(A, p, r) // 获取分区点</span><br><span class="line">  quick_sort_c(A, p, q-<span class="number">1</span>)</span><br><span class="line">  quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<ul>
<li> <strong>partition：</strong> </li>
</ul>
<pre><code>+ 不考虑空间复杂度，可以类似归并的merge。申请两个临时数组 X 和 Y，遍历 A[p...r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p....r]。

  ![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/partition1.jpg)

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::partition3</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[hi - lo + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> tempLindex = <span class="number">0</span>, tempRindex = hi - lo;       <span class="comment">// 临时数组的首末位下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i]) temp[tempLindex++] = arr[i];</span><br><span class="line">        <span class="keyword">if</span> (pivot &lt; arr[i]) temp[tempRindex--] = arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pivot可能是多个相同的值</span></span><br><span class="line">    <span class="keyword">while</span> (tempLindex &lt;= tempRindex) &#123;</span><br><span class="line">        temp[tempLindex++] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        arr[i] = temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

+ 空间复杂度O(1)

  （1）通过游标 i 把 A[p...r-1]分成两部分。A[p...i-1]的元素都是小于 pivot 的，我们暂且叫它 **已处理区间** ，A[i...r-1]是 **未处理区间** 。我们每次都从未处理的区间 A[i...r-1]中取一个元素 **A[j]** ，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。

  （2）数组的插入操作如果考虑顺序，则时间复杂度为O(n)，如果不考虑顺序，则可以实现时间复杂度为O(1)， **即在数组末尾插入一个元素，并与插入位置的元素交换**。

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sort::partition2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[hi];</span><br><span class="line">    <span class="keyword">int</span> i = lo;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; pivot) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[hi]);</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  ![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/partition2.jpg)

+  使用双指针，分别指向数组的首尾，当指针 i 和 j 相遇时主循环退出。在循环中，a[i] 小于pivot时
  我们增大 i ，a[j] 大于pivot时我们减小 j，然后交换a[i] 和a[j] 来保证 i 左侧的元素都不大于 v，j 右侧
  的元素都不小于v。当指针相遇时交换a[lo] 和a[j]，切分结束。

  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sort::partition1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;             <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];                <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束，并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; pivot) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; pivot) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[lo], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

  ![](http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/partition3.png)
</code></pre>
<ul>
<li><p><strong>代码：</strong> </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// version 1 : 空间复杂度O(1)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">QuickSortC</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSortC</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="built_in">partition2</span>(arr, lo, hi);	<span class="comment">// 可用partition2</span></span><br><span class="line">    <span class="built_in">QuickSortC</span>(arr, lo, j - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">QuickSortC</span>(arr, j + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sort::partition1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo, j = hi + <span class="number">1</span>;             <span class="comment">// 左右扫描指针</span></span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];                <span class="comment">// 切分元素</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 扫描左右，检查扫描是否结束，并交换元素</span></span><br><span class="line">        <span class="keyword">while</span> (arr[++i] &lt; pivot) <span class="keyword">if</span> (i == hi) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">while</span> (arr[--j] &gt; pivot) <span class="keyword">if</span> (j == lo) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[lo], arr[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// version 2 : 空间复杂度O(n)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">QuickSortC2</span>(arr, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> parr[<span class="number">2</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::partition3</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[lo];</span><br><span class="line">    <span class="keyword">int</span> *temp = <span class="keyword">new</span> <span class="keyword">int</span>[hi - lo + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> lessPNum = <span class="number">0</span>, largePNum = <span class="number">0</span>;				<span class="comment">// 记录下比哨兵小的和大的个数。</span></span><br><span class="line">    <span class="keyword">int</span> tempLindex = <span class="number">0</span>, tempRindex = hi - lo;       <span class="comment">// 临时数组的首末位下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo + <span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pivot &gt; arr[i])  &#123;</span><br><span class="line">            temp[tempLindex++] = arr[i];</span><br><span class="line">            lessPNum++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pivot &lt; arr[i]) &#123;</span><br><span class="line">            temp[tempRindex--] = arr[i];</span><br><span class="line">            largePNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pivot可能是多个相同的值</span></span><br><span class="line">    <span class="keyword">while</span> (tempLindex &lt;= tempRindex) &#123;</span><br><span class="line">        temp[tempLindex++] = pivot;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = lo, j = <span class="number">0</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">        arr[i] = temp[j++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> temp;</span><br><span class="line">    temp = <span class="literal">nullptr</span>;</span><br><span class="line">    parr[<span class="number">0</span>] = lessPNum;</span><br><span class="line">    parr[<span class="number">1</span>] = largePNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::QuickSortC2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (hi - lo == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[lo] &gt; arr[hi]) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[lo], arr[hi]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">partition3</span>(arr, lo, hi);                   <span class="comment">// 数据分段&#123;&#123;小于哨兵的&#125;， &#123;等于哨兵的&#125;， &#123;大于哨兵的&#125;&#125;</span></span><br><span class="line">        <span class="keyword">int</span> pl_index = lo + parr[<span class="number">0</span>];               <span class="comment">// 首位哨兵的下标</span></span><br><span class="line">        <span class="keyword">int</span> pr_index = hi - parr[<span class="number">1</span>];               <span class="comment">// 末位哨兵的下标</span></span><br><span class="line">        <span class="keyword">if</span> (pl_index == hi &amp;&amp; pl_index != lo)      <span class="comment">// 哨兵位于最右侧，只有左侧需要排序</span></span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, lo, pl_index - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl_index == lo &amp;&amp; pr_index != hi) <span class="comment">// 哨兵位于最左侧，只有右侧需要排序</span></span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, pl_index + <span class="number">1</span>, hi);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pl_index == lo &amp;&amp; pr_index == hi) <span class="comment">// 全是哨兵，直接返回，不需要排序</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;                                     <span class="comment">// 分别对[lo...pl_index-1]，[pr_index+1...hi]排序。</span></span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, lo, pl_index - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">QuickSortC2</span>(arr, pr_index + <span class="number">1</span>, hi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>性能分析：</strong> <ul>
<li>快速排序 是<strong>不稳定的排序算法</strong> 。因为分区的过程涉及交换操作，如果数组中有两个相同的元素，比如序列 6，8，7，6，3，5，9，4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，快速排序并不是一个稳定的排序算法。</li>
<li><strong>时间复杂度</strong> ：<ul>
<li>快排的时间复杂度与归并排序的时间复杂度分析一样， <strong>如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排时间复杂度与归并排序递推求解公式一样，为<code>O(nlogn)</code></strong> 。 <u><strong>公式成立的前提是：每次分区操作选择的pivot合适，正好能将大区间对等地一分为二，但实际上是很难实现的。</strong></u> </li>
<li>如果数组中的数据原来已经是有序的了，比如 1，3，5，6，8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下， <strong>快排的时间复杂度就从 <code>O(nlogn)</code> 退化成了 O(n^2)</strong> 。</li>
</ul>
</li>
<li> <strong>空间复杂度：</strong> <strong>O(1)</strong> 。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p> <strong>如何使用快速排序查找数组中第K大元素？</strong> </p>
</li>
<li><p> <strong>思想：</strong> 我们选择数组区间 A[0…n-1]的最后一个元素 A[n-1]作为 pivot，对数组 A[0…n-1]原地分区，这样数组就分成了三部分，A[0…p-1]、A[p]、A[p+1…n-1]。每次partition之后，分区元素就被放置到正确的位置，如果pivot位于倒数第K个位置即n - K，那么就可以返回。如果 p=n-K，那 A[p]就是要求解的元素；如果 n-K&gt;p, 说明第 K 大元素出现在 A[p+1…n-1]区间，我们再按照上面的思路递归地在 A[p+1…n-1]这个区间内查找。同理，如果 n-K&lt;p，说明第K大元素出现在A[0,p-1]区间。</p>
</li>
<li><p> <strong>时间的复杂度：</strong> 第一次分区查找需要对大小为n的数组执行分区操作，需要遍历n个元素，第二次分区操作只需要对大小为n/2的数组进行分区操作，…，n+n/2+n/4+n/8+…+1 = 2n - 1。因此复杂度为O(n)。</p>
</li>
<li><p><strong>为了尽量保证分区函数的随机性，每次随机取一个元素放到最后作为pivot。</strong></p>
</li>
<li><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, <span class="number">0</span>, n - <span class="number">1</span>, n - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (k == index) <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (k &gt; index) <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, index + <span class="number">1</span>, hi, k);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">quickSort</span>(nums, lo, index - <span class="number">1</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="built_in">rand</span>() % (hi - lo + <span class="number">1</span>) + lo;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[hi]);</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[hi];</span><br><span class="line">        i = lo;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = lo; j &lt; hi; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; pivot) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[hi]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h1 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6.堆排序"></a>6.堆排序</h1><h2 id="1-建堆"><a href="#1-建堆" class="headerlink" title="1.建堆"></a>1.建堆</h2><p><strong>我们首先将数组原地建成一个堆。所谓“原地”就是，不借助另一个数组，就在原数组上操作。</strong></p>
<ul>
<li> <strong>思路一：</strong> 在堆中插入一个元素的思路。尽管数组中包含 n 个数据，但是我们可以假设，起初堆中只包含一个数据，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆。</li>
<li> <strong>思路二：</strong> 第二种实现思路，跟第一种截然相反。第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。 <strong>而第二种实现思路，是从后往前处理数组，并且每个数据都是从上往下堆化。</strong></li>
</ul>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/50c1e6bc6fe68378d0a66bdccfff441e.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/aabb8d15b1b92d5e040895589c60419d.jpg" alt="img"></p>
<p><strong>我们对下标从 <code>n/2</code>开始到 1 的数据进行堆化，下标是<code>n/2 + 1</code>到<code> n</code> 的节点是叶子节点，我们不需要堆化。实际上，对于完全二叉树来说，下标从 <code>n / 2 + 1</code> 到 <code>n</code> 的节点都是叶子节点。</strong></p>
<p><strong>时间复杂度：</strong> 每个节点堆化的时间复杂度是 <code>O(logn)</code>，那 <code>2n+1</code> 个节点堆化的总时间复杂度是不是就是<code> O(nlogn)</code> 呢？这个答案虽然也没错，但是这个值还是不够精确。实际上，堆排序的建堆过程的时间复杂度是<code> O(n)</code>。</p>
<p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度 k 成正比。 <strong>只需要将每个节点的高度求和，得出的就是建堆的时间复杂度。</strong></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/899b9f1b40302c9bd5a7f77f042542d5.jpg" alt="img"></p>
<p>我们将每个非叶子节点的高度求和，就是下面这个公式：</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/f712f8a7baade44c39edde839cefcc09.jpg" alt="img"></p>
<p>把公式左右都乘以 2，就得到另一个公式 <code>S2</code>。我们将 <code>S2</code> 错位对齐，并且用 <code>S2 </code>减去 <code>S1</code>，可以得到 <code>S</code>。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/629328315decd96e349d8cb3940636df.jpg" alt="img"></p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/46ca25edc69b556b967d2c62388b7436.jpg" alt="img"></p>
<p>因为 <code>h=log2n</code>，代入公式 <code>S</code>，就能得到 <code>S=O(n)</code>，所以，建堆的时间复杂度就是 <code>O(n)</code>。</p>
<h2 id="2-排序"><a href="#2-排序" class="headerlink" title="2.排序"></a>2.排序</h2><p>建堆结束之后，数组中的数据已经是按照大顶堆的特性来组织的。数组中的第一个元素就是堆顶，也就是最大的元素。 <strong>我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。</strong> </p>
<p>这个过程有点类似上面讲的“删除堆顶元素”的操作，当堆顶元素移除之后，我们把下标为 <code>n</code> 的元素放到堆顶，然后再通过堆化的方法，将剩下的 <code>n−1</code> 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 <code>n−1</code> 的位置，一直重复这个过程，直到最后堆中只剩下标为 <code>1</code> 的一个元素，排序工作就完成了。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/23958f889ca48dbb8373f521708408d1.jpg" alt="img"></p>
<p><strong>空间复杂度：</strong> 整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。</p>
<p><strong>时间复杂度：</strong> 堆排序包括建堆和排序两个操作，建堆过程的时间复杂度是 <code>O(n)</code>，排序过程的时间复杂度是 <code>O(nlogn)</code>，所以，堆排序整体的时间复杂度是 <code>O(nlogn)</code>。</p>
<p><strong>稳定性：</strong> 堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::buildHeap</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span> ; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(arr, i, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> i, <span class="keyword">int</span> dSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = i;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">2</span> * i + <span class="number">1</span>, right = <span class="number">2</span> * i + <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (left &lt; dSize &amp;&amp; arr[i] &lt; arr[left])</span><br><span class="line">            maxPos = left;</span><br><span class="line">        <span class="keyword">if</span> (right &lt; dSize &amp;&amp; arr[maxPos] &lt; arr[right])</span><br><span class="line">            maxPos = right;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[maxPos]);</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort::heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 建堆</span></span><br><span class="line">    <span class="built_in">buildHeap</span>(arr);</span><br><span class="line">    <span class="comment">// 控制堆化的数量，每次交换完元素后要减1</span></span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="comment">// 把堆顶最大的元素与最后一个位置交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);</span><br><span class="line">        <span class="comment">// 从堆顶开始往下堆化</span></span><br><span class="line">        <span class="built_in">heapify</span>(arr, <span class="number">0</span>, --k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么快排要比堆排序好？"><a href="#为什么快排要比堆排序好？" class="headerlink" title="为什么快排要比堆排序好？"></a>为什么快排要比堆排序好？</h2><ul>
<li><p>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/838a38286dcace89ca63895b77ae8ece.jpg" alt="img"></p>
</li>
<li><p>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</p>
<p>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。 <strong>快速排序数据交换的次数不会比逆序度多。</strong> </p>
<p>但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/6e81fdde42ec3fd288d32eb866867fbd.jpg" alt="img"></p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%A0%88%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h2 id="栈的结构"><a href="#栈的结构" class="headerlink" title="栈的结构"></a>栈的结构</h2><p><strong>后进者先出，先进者后出，这就是典型的“栈”结构。</strong>栈是一种<strong>“操作受限”</strong>的线性表，只允许在一端插入和删除数据。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313172646.jpeg" alt="img" style="zoom:50%;" />

<h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<strong>顺序栈</strong>，用链表实现的栈，我们叫作<strong>链式栈</strong>。</p>
<ul>
<li><p>空间复杂度：我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以**空间复杂度是 O(1)**。</p>
</li>
<li><p>时间复杂度：时间复杂度也不难。不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以**时间复杂度都是 O(1)**。</p>
</li>
</ul>
<p><strong>支持动态扩容的顺序栈</strong></p>
<p>当数组空间不够时，我们就重新申请一块更大的内存，将原来数组中数据统统拷贝过去。这样就实现了一个支持动态扩容的数组。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313173357.jpeg" alt="img" style="zoom:50%;" />

<ul>
<li><strong>出栈时间复杂度</strong>：对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。</li>
<li><strong>入栈时间复杂度：</strong>对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。<strong>最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)，平均情况下的时间复杂度为O(1)</strong></li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul>
<li><p><strong>栈在函数调用中的应用</strong></p>
<p>操作系统给每个线程分配了一块独立的内存空间，这块内存被组织成“栈”这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈。</p>
</li>
<li><p><strong>栈在表达式求值中的应用</strong></p>
<p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。</p>
<p>如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174152.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p><strong>栈在括号匹配中的应用</strong></p>
<p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式；否则，说明有未匹配的左括号，为非法格式。</p>
</li>
<li><p><strong>如何实现浏览器的前进和后退功能</strong></p>
<p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。</p>
<ul>
<li><p>比如你顺序查看了 a，b，c 三个页面，我们就依次把 a，b，c 压入栈，这个时候，两个栈的数据就是这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174508.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174527.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174548.jpeg" alt="img" style="zoom:50%;" /></li>
<li><p>这个时候，你通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。此时两个栈的数据这个样子：</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313174616.jpeg" alt="img" style="zoom:50%;" /></li>
</ul>
</li>
</ul>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li><p><strong>讲到用函数调用栈来保存临时变量，为什么函数调用要用“栈”来保存临时变量呢？用其他数据结构不行吗？</strong></p>
<p>其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。</p>
<p>从调用函数进入被调用函数，对于数据来说，变化的是什么呢？是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%93%E9%A2%98/</url>
    <content><![CDATA[<h1 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h1><h2 id="散列表（上）"><a href="#散列表（上）" class="headerlink" title="散列表（上）"></a>散列表（上）</h2><h3 id="1-散列思想："><a href="#1-散列思想：" class="headerlink" title="1.散列思想："></a>1.散列思想：</h3><p><strong>散列表(Hash Table)用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。</strong></p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/92c89a57e21f49d2f14f4424343a2773.jpg" alt="img" style="zoom: 50%;" />

<ul>
<li>特性：<ul>
<li>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 <code>O(1)</code> 的特性。</li>
<li>我们通过 <strong>散列函数把元素的键值映射为下标，即hash(key)</strong> ，然后将数据存储在数组中对应下标的位置。</li>
<li>当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</li>
</ul>
</li>
</ul>
<h3 id="2-散列函数"><a href="#2-散列函数" class="headerlink" title="2.散列函数"></a>2.散列函数</h3><p>顾名思义，它是一个函数。我们可以把它定义成  <strong>hash(key)</strong> ，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。</p>
<p>举个例子：假如我们有 89 名选手参加学校运动会。为了方便记录成绩，每个选手胸前都会贴上自己的参赛号码。这 89 名选手的编号依次是 1 到 89。现在我们希望编程实现这样一个功能，通过编号快速找到对应的选手信息。你会怎么做呢？</p>
<p>我们可以把这 89 名选手的信息（年纪，班级，编号）放在数组里。编号为 1 的选手，我们放到数组中下标为 1 的位置；编号为 2 的选手，我们放到数组中下标为 2 的位置。以此类推，编号为 k 的选手放到数组中下标为 k 的位置。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取后两位字符</span></span><br><span class="line">  string lastTwoChars = key.<span class="built_in">substr</span>(length<span class="number">-2</span>, length);</span><br><span class="line">  <span class="comment">// 将后两位字符转换为整数</span></span><br><span class="line">  <span class="keyword">int</span> hashValue = convert lastTwoChas to <span class="keyword">int</span>-type;</span><br><span class="line">  <span class="keyword">return</span> hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>散列函数设计的 <strong>基本要求：</strong><ul>
<li>散列函数计算得到的散列值是一个非负整数；（数组下标从0开始）</li>
<li>如果 <code>key1 = key2</code>，那 <code>hash(key1) == hash(key2)；</code></li>
<li>如果 <code>key1 ≠ key2</code>，那 <code>hash(key1) ≠ hash(key2)。</code><strong>但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的，这就是散列冲突。</strong></li>
</ul>
</li>
</ul>
<h3 id="3-散列冲突"><a href="#3-散列冲突" class="headerlink" title="3.散列冲突"></a>3.散列冲突</h3><h4 id="1-开放寻址法"><a href="#1-开放寻址法" class="headerlink" title="1.开放寻址法"></a><strong>1.开放寻址法</strong></h4><p><strong>思想：</strong> 如果出现了散列冲突，我们就重新 <strong>探测</strong> 一个空闲位置，将其插入。探测方法有线性探测，</p>
<ul>
<li><p><strong>线性探测（Linear Probing）</strong> </p>
</li>
<li><p>当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313091944.jpeg" alt="img" style="zoom: 50%;" />

<ul>
<li><p><strong>插入：</strong> 散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找，直到找到空闲位置 2，于是将其插入到这个位置。</p>
</li>
<li><p><strong>查找：</strong> 我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中。</p>
</li>
<li><p><strong>删除：</strong> 将删除的元素，特殊标记为 deleted。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/fe7482ba09670cbe05a9dfe4dd49bd1d.jpg" alt="img" style="zoom:50%;" />

<blockquote>
<p><strong>我们不能单纯地把要删除的元素设置为空。</strong> 这是为什么呢？</p>
<p>在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。这个问题如何解决呢？</p>
</blockquote>
</li>
<li><p><strong>缺点：</strong> 当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。极端情况下，我们可能需要探测整个散列表，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p>
</li>
</ul>
</li>
<li><p><strong>二次探测：</strong> 跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 <code>hash(key)+0，hash(key)+1，hash(key)+2……</code>而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 <code>hash(key)+0，hash(key)+1^2，hash(key)+2^2……</code></p>
</li>
<li><p><strong>双重散列：</strong> 意思就是不仅要使用一个散列函数。我们使用一组散列函数 <code>hash1(key)，hash2(key)，hash3(key)……</code>我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p>
</li>
<li><p><strong>装载因子：</strong> 不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用 <strong>装载因子（load factor）</strong> 来表示空位的多少。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">散列表的装载因子=填入表中的元素个数/散列表的长度</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="2-链表法"><a href="#2-链表法" class="headerlink" title="2.链表法"></a>2.链表法</h4><p>链表法是一种更加常用的散列冲突解决办法，相比开放寻址法，它要简单很多。在散列表中，每个“桶（bucket）”或者“槽（slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/a4b77d593e4cb76acb2b0689294ec17f.jpg" alt="img" style="zoom:50%;" />

<ul>
<li><strong>插入：</strong> 通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 <code>O(1)</code>。</li>
<li><strong>查找，删除：</strong> 当查找、删除一个元素时，通过散列函数计算出对应的槽，然后遍历链表查找或者删除。这两个操作的 <strong>时间复杂度</strong> 跟链表的长度<code> k</code> 成正比，也就是 <code>O(k)</code>。对于散列比较均匀的散列函数来说，理论上讲，<code>k=n/m</code>，其中 <code>n</code> 表示<strong>散列中数据的个数</strong>，<code>m</code> 表示散列表中<strong>“槽”的个数</strong>。</li>
</ul>
<h3 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h3><ul>
<li><p>假设我们有 10 万条 URL 访问日志，如何按照访问次数给 URL 排序？</p>
<ul>
<li>遍历 10 万条数据，以 <code>URL</code> 为 <code>key</code>，访问次数为 <code>value</code>，存入散列表，同时记录下访问次数的最大值 <code>K</code>，时间复杂度 <code>O(N)</code>。如果 <code>K</code> 不是很大，可以使用桶排序，时间复杂度 <code>O(N)</code>。如果 <code>K</code> 非常大（比如大于 10 万），就使用快速排序，复杂度 <code>O(NlogN)</code>。</li>
</ul>
</li>
<li><p>有两个字符串数组，每个数组大约有 10 万条字符串，如何快速找出两个数组中相同的字符串？</p>
<ul>
<li>以第一个字符串数组构建散列表，<code>key </code>为字符串，<code>value</code> 为出现次数。再遍历第二个字符串数组，以字符串为 <code>key</code> 在散列表中查找，如果 <code>value</code> 大于零，说明存在相同字符串。时间复杂度 <code>O(N)</code>。</li>
</ul>
</li>
<li><p>Word 文档中单词拼写检查功能是如何实现的？</p>
<ul>
<li>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 <code>2MB</code> 的存储空间，就算放大 10 倍也就是 <code>20MB</code>。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；如果没有查到，则说明拼写可能有误，给予提示。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</li>
</ul>
</li>
</ul>
<h2 id="散列表（中）"><a href="#散列表（中）" class="headerlink" title="散列表（中）"></a>散列表（中）</h2><h3 id="工业级的散列表应该具有哪些特性？"><a href="#工业级的散列表应该具有哪些特性？" class="headerlink" title="工业级的散列表应该具有哪些特性？"></a><strong>工业级的散列表应该具有哪些特性？</strong></h3><ul>
<li><strong>支持快速地查询、插入、删除操作；</strong></li>
<li><strong>内存占用合理，不能浪费过多的内存空间；</strong></li>
<li><strong>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况。</strong></li>
</ul>
<h3 id="1-如何设计散列函数？"><a href="#1-如何设计散列函数？" class="headerlink" title="1.如何设计散列函数？"></a>1.如何设计散列函数？</h3><ul>
<li>散列函数的设计不能太复杂。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能。</li>
<li>散列函数生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。<strong>散列表会退化为链表</strong></li>
</ul>
<h3 id="2-装载因子过大了怎么办？"><a href="#2-装载因子过大了怎么办？" class="headerlink" title="2.装载因子过大了怎么办？"></a>2.装载因子过大了怎么办？</h3><p><strong>装载因子越大，说明散列表中的元素越多，空闲位置越少，散列冲突的概率就越大。</strong>不仅插入数据的过程要多次寻址或者拉很长的链，查找的过程也会因此变得很慢。</p>
<ul>
<li><p><strong>静态数据集合：</strong> 没有频繁插入和删除，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。</p>
</li>
<li><p><strong>动态数据集合：</strong> 数据集合是频繁变动的，我们事先无法预估将要加入的数据个数，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。这个时候，我们该如何处理呢？</p>
<ul>
<li><p><strong>动态扩容：</strong> 当装载因子过大时，我们也可以进行动态扩容，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。针对数组的扩容，数据搬移操作比较简单。但是，<strong>针对散列表的扩容，数据搬移操作要复杂很多。</strong>因为散列表的大小变了，<strong>数据的存储位置也变了</strong>，所以我们需要通过散列函数重新计算每个数据的存储位置。</p>
</li>
<li><p><strong>插入：</strong> 插入一个数据，最好情况下，不需要扩容，**最好时间复杂度是 O(1)<strong>。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，</strong>所以时间复杂度是 O(n)**。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。</p>
</li>
<li><p><strong>删除：</strong> 随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们可以在装载因子小于某个值之后，启动动态缩容。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p>
</li>
</ul>
</li>
</ul>
<h3 id="3-如何避免低效的扩容？"><a href="#3-如何避免低效的扩容？" class="headerlink" title="3.如何避免低效的扩容？"></a>3.如何避免低效的扩容？</h3><p>为了解决一次性扩容耗时过多的情况，我们可以将<strong>扩容操作穿插在插入操作的过程中，分批完成。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。</strong></p>
<ul>
<li><p>当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/6d6736f986ec4b75dabc5472965fb9cb.jpg" alt="img" style="zoom:50%;" /></li>
</ul>
<p>通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 **O(1)**。</p>
<h3 id="4-如何选择冲突解决方法？"><a href="#4-如何选择冲突解决方法？" class="headerlink" title="4.如何选择冲突解决方法？"></a>4.如何选择冲突解决方法？</h3><ul>
<li><p><strong>开放寻址法：</strong> </p>
<ul>
<li><strong>优点：</strong> 散列表中的数据都存储在数组中，可以有效地利用 CPU 缓存加快查询速度。而且，这种方法实现的散列表，序列化起来比较简单</li>
<li><strong>缺点：</strong> 用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，比起链表法来说，冲突的代价更高。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</li>
<li><strong>适用场景：</strong> <strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法。</strong></li>
</ul>
</li>
<li><p><strong>链表法：</strong> </p>
<ul>
<li><p><strong>优点：</strong></p>
<ul>
<li>链表法对内存的利用率比开放寻址法要高。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。实际上，这一点也是我们前面讲过的链表优于数组的地方。</li>
<li>链表法比起开放寻址法，对大装载因子的容忍度更高。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</li>
</ul>
</li>
<li><p><strong>缺点：</strong> 链表因为要存储指针，所以对于比较小的对象的存储，是比较消耗内存的，还有可能会让内存的消耗翻倍。而且，因为链表中的结点是零散分布在内存中的，不是连续的，所以对 CPU 缓存是不友好的，这方面对于执行效率也有一定的影响。</p>
</li>
<li><p><strong>改造：</strong> 实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们将链表法中的链表改造为其他高效的动态数据结构，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是<code> O(logn)</code>。这样也就有效避免了前面讲到的散列碰撞攻击。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313100019.jpeg" alt="img"></p>
</li>
<li><p><strong>适用场景：</strong> <strong>基于链表的散列冲突处理方法比较适合存储大对象、大数据量的散列表，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</strong></p>
</li>
</ul>
</li>
</ul>
<h2 id="散列表（下）"><a href="#散列表（下）" class="headerlink" title="散列表（下）"></a>散列表（下）</h2><h3 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h3><p>我们需要维护一个按照访问时间从大到小有序排列的链表结构。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的<strong>尾部</strong>删除。</p>
<p>当要缓存某个数据的时候，先在链表中查找这个数据。如果没有找到，则直接将数据放到链表的<strong>头部</strong>；如果找到了，我们就把它移动到链表的<strong>头部</strong>。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 **O(n)**。</p>
<p><img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/image-20210330104857654.png" alt="image-20210330104857654"></p>
<p>一个缓存（cache）系统主要包含下面这几个操作：</p>
<ul>
<li><strong>往缓存中添加一个数据；</strong><ul>
<li>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的头部。</li>
</ul>
</li>
<li><strong>从缓存中删除一个数据；</strong><ul>
<li>我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度。</li>
</ul>
</li>
<li><strong>在缓存中查找一个数据。</strong><ul>
<li>添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的头部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的尾部删除，然后再将数据放到链表的头部；如果没有满，就直接将数据放到链表的头部。</li>
</ul>
</li>
</ul>
<p>这三个操作都要涉及“查找”操作，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。</p>
<img src="http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313143709.jpeg" alt="img" style="zoom:50%;" />

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DLinkedNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* prev;</span><br><span class="line">    DLinkedNode* next;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>() : <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">DLinkedNode</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _value) : <span class="built_in">key</span>(_key), <span class="built_in">value</span>(_value), <span class="built_in">prev</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, DLinkedNode*&gt; cache;</span><br><span class="line">    <span class="keyword">int</span> key, value;</span><br><span class="line">    DLinkedNode* head;</span><br><span class="line">    DLinkedNode* tail;</span><br><span class="line">    <span class="keyword">int</span> capacity, size;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> _capacity) : <span class="built_in">capacity</span>(_capacity), <span class="built_in">size</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        head = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        tail = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>();</span><br><span class="line">        head-&gt;next = tail;</span><br><span class="line">        tail-&gt;prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先查找key在不在cache中，如果在就移到头部</span></span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) == cache.<span class="built_in">end</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 获取值并put</span></span><br><span class="line">        <span class="keyword">int</span> val = cache[key]-&gt;value;</span><br><span class="line">        <span class="built_in">put</span>(key, val);</span><br><span class="line">        <span class="keyword">return</span> val;  </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cache.<span class="built_in">find</span>(key) != cache.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            DLinkedNode* tmp = cache[key];</span><br><span class="line">            <span class="comment">// 更新数据</span></span><br><span class="line">            tmp-&gt;value = value;</span><br><span class="line">            <span class="comment">// 移到头部</span></span><br><span class="line">            <span class="built_in">moveToHead</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 新建节点，并插入</span></span><br><span class="line">            DLinkedNode* node = <span class="keyword">new</span> <span class="built_in">DLinkedNode</span>(key, value);</span><br><span class="line">            <span class="built_in">addFirst</span>(node);</span><br><span class="line">            cache[key] = node;</span><br><span class="line">            ++size;</span><br><span class="line">            <span class="comment">// 判断缓存容量是否达到上限</span></span><br><span class="line">            <span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line">                DLinkedNode* last = <span class="built_in">removeLast</span>();</span><br><span class="line">                cache.<span class="built_in">erase</span>(last-&gt;key);</span><br><span class="line">                --size;</span><br><span class="line">                <span class="keyword">delete</span> last;</span><br><span class="line">                last = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向头部添加节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;next = head-&gt;next;</span><br><span class="line">        node-&gt;prev = head;</span><br><span class="line">        head-&gt;next-&gt;prev = node;</span><br><span class="line">        head-&gt;next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除x节点</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;prev-&gt;next = node-&gt;next;</span><br><span class="line">        node-&gt;next-&gt;prev = node-&gt;prev;</span><br><span class="line">        <span class="comment">// delete node;</span></span><br><span class="line">        <span class="comment">// node = nullptr;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将节点移至头部</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">moveToHead</span><span class="params">(DLinkedNode* node)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">remove</span>(node);</span><br><span class="line">        <span class="built_in">addFirst</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">DLinkedNode* <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DLinkedNode* tmp = tail-&gt;prev;</span><br><span class="line">        <span class="built_in">remove</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your LRUCache object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * LRUCache* obj = new LRUCache(capacity);</span></span><br><span class="line"><span class="comment"> * int param_1 = obj-&gt;get(key);</span></span><br><span class="line"><span class="comment"> * obj-&gt;put(key,value);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
