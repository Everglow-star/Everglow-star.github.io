<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>奋斗的🐖</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2021-07-12T07:17:19.205Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>英伦82年雪碧</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基本架构：一个键值数据库包含什么？</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%9F%BA%E6%9C%AC%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E4%B8%AA%E9%94%AE%E5%80%BC%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8C%85%E5%90%AB%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T07:17:19.205Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;Redis主体&quot;&gt;&lt;a href=&quot;#Redis主体&quot; class=&quot;headerlink&quot; title=&quot;Redis主体&quot;&gt;&lt;/a&gt;&lt;code&gt;Redis&lt;/code&gt;主体&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;Redis&lt;/code&gt;知识整体框架&lt;/strong&gt;&lt;/p&gt;
&lt;img src=&quot;http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/79da7093ed998a99d9abe91e610b74e7.jpg&quot; alt=&quot;img&quot; style=&quot;zoom: 25%;&quot; /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高性能主线：&lt;/strong&gt; 包括线程模型、数据结构、持久化、网络框架；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可靠主线：&lt;/strong&gt;包括主从复制、哨兵机制；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;高可扩展主线：&lt;/strong&gt;包括数据分片、负载均衡。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>数据结构：快速的Redis有哪些慢操作？</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C%EF%BC%9F/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%BF%AB%E9%80%9F%E7%9A%84Redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%85%A2%E6%93%8D%E4%BD%9C%EF%BC%9F/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T07:16:45.803Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;数据结构：快速的Redis有哪些慢操作？&quot;&gt;&lt;a href=&quot;#数据结构：快速的Redis有哪些慢操作？&quot; class=&quot;headerlink&quot; title=&quot;数据结构：快速的Redis有哪些慢操作？&quot;&gt;&lt;/a&gt;数据结构：快速的&lt;code&gt;Redis&lt;/code&gt;有哪些慢操作？&lt;/h1&gt;&lt;p&gt;底层数据结构一共有 6 种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。&lt;/p&gt;
&lt;img src=&quot;http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/8219f7yy651e566d47cc9f661b399f01.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:20%;&quot; /&gt;

&lt;p&gt;可以看到，String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型， &lt;strong&gt;它们的特点是一个键对应了一个集合的数据。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这些数据结构都是值的底层实现，键和值本身之间用什么结构组织？&lt;/li&gt;
&lt;li&gt;为什么集合类型有那么多的底层结构，它们都是怎么组织数据的，都很快吗？&lt;/li&gt;
&lt;li&gt;什么是简单动态字符串，和常用的字符串是一回事吗？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T12:15:36.681Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;h2 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h2&gt;&lt;img src=&quot;http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/b7043bf29a253bb36221eaec62b2e129.jpg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="algorithms" scheme="http://example.com/tags/algorithms/"/>
    
  </entry>
  
  <entry>
    <title>栈</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T05:44:00.146Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;栈的结构&quot;&gt;&lt;a href=&quot;#栈的结构&quot; class=&quot;headerlink&quot; title=&quot;栈的结构&quot;&gt;&lt;/a&gt;栈的结构&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;后进者先出，先进者后出，这就是典型的“栈”结构。&lt;/strong&gt;栈是一种&lt;strong&gt;“操作受限”&lt;/strong&gt;的线性表，只允许在一端插入和删除数据。&lt;/p&gt;
&lt;img src=&quot;http://lihuitao-picture.oss-cn-beijing.aliyuncs.com/img/20210313172646.jpeg&quot; alt=&quot;img&quot; style=&quot;zoom:50%;&quot; /&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T05:41:49.342Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;链表（上）&quot;&gt;&lt;a href=&quot;#链表（上）&quot; class=&quot;headerlink&quot; title=&quot;链表（上）&quot;&gt;&lt;/a&gt;链表（上）&lt;/h1&gt;&lt;h2 id=&quot;链表结构&quot;&gt;&lt;a href=&quot;#链表结构&quot; class=&quot;headerlink&quot; title=&quot;链表结构&quot;&gt;&lt;/a&gt;链表结构&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;数组需要一块 &lt;strong&gt;连续&lt;/strong&gt; 的内存空间来存储，链表恰恰相反，它并 &lt;strong&gt;不需要一块连续&lt;/strong&gt; 的内存空间，它通过“指针”将一组零散的内存块串联起来使用。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis并发问题</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T11:50:54.417Z</updated>
    
    
      
      
        
        
    <summary type="html">&lt;h1 id=&quot;无锁的原子操作：Redis如何应对并发访问？&quot;&gt;&lt;a href=&quot;#无锁的原子操作：Redis如何应对并发访问？&quot; class=&quot;headerlink&quot;</summary>
        
      
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T05:40:59.568Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;二分思想&quot;&gt;&lt;a href=&quot;#二分思想&quot; class=&quot;headerlink&quot; title=&quot;二分思想&quot;&gt;&lt;/a&gt;二分思想&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;二分查找针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为 0。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%A0%86%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T05:39:48.412Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;如何理解“堆”？&quot;&gt;&lt;a href=&quot;#如何理解“堆”？&quot; class=&quot;headerlink&quot; title=&quot;如何理解“堆”？&quot;&gt;&lt;/a&gt;如何理解“堆”？&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;堆是一个完全二叉树，除了最后一层，其他层的节点个数都是满的，最后一层的节点都靠左排列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做“大顶堆”。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做“小顶堆”。&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>散列表</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%A3%E5%88%97%E8%A1%A8%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T05:43:09.790Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;散列表&quot;&gt;&lt;a href=&quot;#散列表&quot; class=&quot;headerlink&quot; title=&quot;散列表&quot;&gt;&lt;/a&gt;散列表&lt;/h1&gt;&lt;h2 id=&quot;散列表（上）&quot;&gt;&lt;a href=&quot;#散列表（上）&quot; class=&quot;headerlink&quot; title=&quot;散列表（上）&quot;&gt;&lt;/a&gt;散列表（上）&lt;/h2&gt;&lt;h3 id=&quot;1-散列思想：&quot;&gt;&lt;a href=&quot;#1-散列思想：&quot; class=&quot;headerlink&quot; title=&quot;1.散列思想：&quot;&gt;&lt;/a&gt;1.散列思想：&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;散列表(Hash Table)用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展，由数组演化而来。可以说，如果没有数组，就没有散列表。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F%E4%B8%93%E9%A2%98/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T05:42:37.952Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;如何分析一个排序算法？&quot;&gt;&lt;a href=&quot;#如何分析一个排序算法？&quot; class=&quot;headerlink&quot; title=&quot;如何分析一个排序算法？&quot;&gt;&lt;/a&gt;如何分析一个排序算法？&lt;/h1&gt;&lt;h2 id=&quot;1-排序算法的执行效率&quot;&gt;&lt;a href=&quot;#1-排序算法的执行效率&quot; class=&quot;headerlink&quot; title=&quot;1. 排序算法的执行效率&quot;&gt;&lt;/a&gt;1. 排序算法的执行效率&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt; &lt;strong&gt;最好情况、最坏情况、平均情况时间复杂度&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt;分别给出排序算法 &lt;strong&gt;三种情况&lt;/strong&gt; 的时间复杂度&lt;/li&gt;
&lt;li&gt;同时给出三种情况时间复杂度对应的 &lt;strong&gt;原始数据&lt;/strong&gt; 是什么样的？&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;时间复杂度的系数、常数 、低阶&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;时间复杂度反映的是数据规模 n **很大 **的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。&lt;/li&gt;
&lt;li&gt;实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模 &lt;strong&gt;很小&lt;/strong&gt; 的数据，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来。&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;比较次数和交换（或移动）次数&lt;/strong&gt; ：基于 &lt;strong&gt;比较&lt;/strong&gt; 的排序算法执行过程中，会涉及两种操作。&lt;/li&gt;
&lt;li&gt; &lt;strong&gt;元素比较大小&lt;/strong&gt; &lt;/li&gt;
&lt;li&gt; &lt;strong&gt;元素交换或移动&lt;/strong&gt; &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据结构与算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis缓存</title>
    <link href="http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/"/>
    <id>http://example.com/2021/07/12/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2021-07-12T08:52:21.894Z</updated>
    
    
    <summary type="html">&lt;h1 id=&quot;旁路缓存：Redis是如何工作的？&quot;&gt;&lt;a href=&quot;#旁路缓存：Redis是如何工作的？&quot; class=&quot;headerlink&quot; title=&quot;旁路缓存：Redis是如何工作的？&quot;&gt;&lt;/a&gt;旁路缓存：&lt;code&gt;Redis&lt;/code&gt;是如何工作的？&lt;/h1&gt;&lt;p&gt;&lt;code&gt;Redis&lt;/code&gt; 提供了高性能的数据存取功能，所以广泛应用在缓存场景中，既能有效地提升业务应用的响应速度，还可以避免把高并发大压力的请求发送到数据库层。但是，如果 &lt;code&gt;Redis&lt;/code&gt; 做缓存时出现了问题，比如说缓存失效，那么，大量请求就会直接积压到数据库层，必然会给数据库带来巨大的压力，很可能会导致数据库宕机或是故障，那么，业务应用就没有办法存取数据、响应用户请求了。这种生产事故，肯定不是我们希望看到的。&lt;/p&gt;
&lt;p&gt;正因为 &lt;code&gt;Redis&lt;/code&gt; 用作缓存的普遍性以及它在业务应用中的重要作用，所以，我们需要系统地掌握缓存的一系列内容，包括工作原理、替换策略、异常处理和扩展机制。具体来说，我们需要解决四个关键问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 缓存具体是怎么工作的？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 缓存如果满了，该怎么办？&lt;/li&gt;
&lt;li&gt;为什么会有缓存一致性、缓存穿透、缓存雪崩、缓存击穿等异常，该如何应对？&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Redis&lt;/code&gt; 的内存毕竟有限，如果用快速的固态硬盘来保存数据，可以增加缓存的数据量，那么，&lt;code&gt;Redis&lt;/code&gt; 缓存可以使用快速固态硬盘吗？&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="数据库" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
  </entry>
  
</feed>
